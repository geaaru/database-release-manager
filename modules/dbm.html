<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title># Internal functions</title>
    
    <link rel="stylesheet" href="../static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <p>#!/bin/bash
#&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
# Author(s): Geaaru, <a class="reference external" href="mailto:geaaru&#37;&#52;&#48;gmail&#46;com">geaaru<span>&#64;</span>gmail<span>&#46;</span>com</a>
# $Id: f54e83f5b61f5fcf4b5e185c6ef8acfab9c25b1e $
# License: GPL 2.0
#&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
<p>name=&#8221;dbm&#8221;
dbm_authors=&#8221;Geaaru&#8221;
dbm_creation_date=&#8221;May 5, 2013&#8221;
dbm_version=&#8221;0.1.0&#8221;</p>
<p>dbm_schema=${prefix}/share/dbrm/dbm_sqlite_schema.sql</p>
<p># List of tables of sqlite database used by dbm modules.
dbm_tables=&#8221;</p>
<blockquote>
<div>ScriptTypes
DatabaseAdapters
Releases
Branches
ReleasesDependencies
Scripts
ScriptRelInhibitions
ScriptRelDedicated
Profiles
Extensions</div></blockquote>
<p>&#8220;</p>
<p># dbm_dbm_version
dbm_version() {</p>
<blockquote>
<div><p>echo -en &#8220;Version: ${dbm_version}n&#8221;</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_version_end</p>
<p># dbm_dbm_long_help
dbm_long_help () {</p>
<blockquote>
<div><p>echo -en &#8220;===========================================================================n&#8221;
echo -en &#8220;Module [dbm]:n&#8221;
echo -en &#8220;Author(s): ${dbm_authors}n&#8221;
echo -en &#8220;Created: ${dbm_creation_date}n&#8221;
echo -en &#8220;Version: ${dbm_version}n&#8221;
echo -en &#8220;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;n&#8221;
echo -en &#8220;tlong_help               Show long help informationsn&#8221;
echo -en &#8220;tshow_help               Show command list.n&#8221;
echo -en &#8220;tversion                 Show module version.n&#8221;
echo -en &#8220;tshow_releases           Show releases.n&#8221;
echo -en &#8220;tshow_adapters           Show database adaptersn&#8221;
echo -en &#8220;tshow_script_types       Show script types.n&#8221;
echo -en &#8220;tshow_scripts            Show scripts.n&#8221;
echo -en &#8220;tshow_rel_dep            Show release dependencies.n&#8221;
echo -en &#8220;tshow_inhibit_scripts    Show inhibited scripts.n&#8221;
echo -en &#8220;tshow_rel_ded_scripts    Show release dedicated scripts.n&#8221;
echo -en &#8220;tinsert_inhibit_script   Insert a new inhibit script relationship.n&#8221;
echo -en &#8220;tremove_inhibit_script   Remove an inhibit script relationship.n&#8221;
echo -en &#8220;tinsert_ded_script       Insert a new release dedicated script relationship.n&#8221;
echo -en &#8220;tremove_ded_script       Remove a release dedicated script relationship.n&#8221;
echo -en &#8220;tinsert_release          Insert a new release.n&#8221;
echo -en &#8220;tmove_release            Move release position.n&#8221;
echo -en &#8220;tupdate_release          Update a release data.n&#8221;
echo -en &#8220;tremove_release          Remove a release.n&#8221;
echo -en &#8220;tinsert_script_type      Insert a new script type.n&#8221;
echo -en &#8220;tinsert_rel_dep          Insert a new release dependency.n&#8221;
echo -en &#8220;tremove_rel_dep          Remove release dependency.n&#8221;
echo -en &#8220;tinsert_script           Insert a new script.n&#8221;
echo -en &#8220;tupdate_script           Update a script by Id.n&#8221;
echo -en &#8220;tremove_script           Remove script.n&#8221;
echo -en &#8220;tmove_script             Move script.n&#8221;
echo -en &#8220;tshow_branches           Show branches.n&#8221;
echo -en &#8220;tinsert_branch           Insert a new branch.n&#8221;
echo -en &#8220;tshow_profiles           Show profilesn&#8221;
echo -en &#8220;tadd_profile             Add a new profile to project.n&#8221;
echo -en &#8220;tdel_profile             Remove a profile from project.n&#8221;
echo -en &#8220;tset_profile             Set default profile of the project.n&#8221;
echo -en &#8220;tinfo                    Show informations about dbm parameters and project.n&#8221;
echo -en &#8220;tshell                   Enter on sqlite dbm database.n&#8221;
echo -en &#8220;tupgrade                 Check if dbrm database is align to last release andn&#8221;
echo -en &#8220;t                        create new tables.n&#8221;
echo -en &#8220;tinitenv                 Create a new empty dbrm database and a dbrm.confn&#8221;
echo -en &#8220;t                        on current directory.n&#8221;
echo -en &#8220;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;n&#8221;
echo -en &#8220;===========================================================================n&#8221;</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_long_help_end</p>
<p># dbm_dbm_show_help
dbm_show_help () {</p>
<blockquote>
<div><p>echo -en &#8220;===========================================================================n&#8221;
echo -en &#8220;Module [dbm]:n&#8221;
echo -en &#8220;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;n&#8221;
echo -en &#8220;tlong_help               Show long help informationsn&#8221;
echo -en &#8220;tshow_releases           Show releases.n&#8221;
echo -en &#8220;tshow_adapters           Show database adaptersn&#8221;
echo -en &#8220;tshow_script_types       Show script types.n&#8221;
echo -en &#8220;tshow_scripts            Show scripts.n&#8221;
echo -en &#8220;tshow_rel_dep            Show release dependencies.n&#8221;
echo -en &#8220;tshow_inhibit_scripts    Show inhibited scripts.n&#8221;
echo -en &#8220;tshow_rel_ded_scripts    Show release dedicated scripts.n&#8221;
echo -en &#8220;tinsert_inhibit_script   Insert a new inhibit script relationship.n&#8221;
echo -en &#8220;tremove_inhibit_script   Remove an inhibit script relationship.n&#8221;
echo -en &#8220;tinsert_ded_script       Insert a new release dedicated script relationship.n&#8221;
echo -en &#8220;tremove_ded_script       Remove a release dedicated script relationship.n&#8221;
echo -en &#8220;tinsert_release          Insert a new release.n&#8221;
echo -en &#8220;tmove_release            Move release position.n&#8221;
echo -en &#8220;tupdate_release          Update a release data .n&#8221;
echo -en &#8220;tremove_release          Remove a release.n&#8221;
echo -en &#8220;tinsert_script_type      Insert a new script type.n&#8221;
echo -en &#8220;tinsert_rel_dep          Insert a new release dependency.n&#8221;
echo -en &#8220;tremove_rel_dep          Remove release dependency.n&#8221;
echo -en &#8220;tinsert_script           Insert a new script.n&#8221;
echo -en &#8220;tupdate_script           Update a script by Id.n&#8221;
echo -en &#8220;tremove_script           Remove script.n&#8221;
echo -en &#8220;tmove_script             Move script.n&#8221;
echo -en &#8220;tshow_branches           Show branches.n&#8221;
echo -en &#8220;tinsert_branch           Insert a new branch.n&#8221;
echo -en &#8220;tshow_profiles           Show profilesn&#8221;
echo -en &#8220;tadd_profile             Add a new profile to project.n&#8221;
echo -en &#8220;tdel_profile             Remove a profile from project.n&#8221;
echo -en &#8220;tset_profile             Set default profile of the project.n&#8221;
echo -en &#8220;tinfo                    Show informations about dbm parameters and project.n&#8221;
echo -en &#8220;tshell                   Enter on sqlite dbm database.n&#8221;
echo -en &#8220;tupgrade                 Check if dbrm database is align to last release andn&#8221;
echo -en &#8220;t                        create new tables.n&#8221;
echo -en &#8220;tinitenv                 Create a new empty dbrm database and a dbrm.confn&#8221;
echo -en &#8220;t                        on current directory.n&#8221;
echo -en &#8220;===========================================================================n&#8221;</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_help_end</p>
<p># dbm_dbm_info
dbm_info () {</p>
<blockquote>
<div><dl class="docutils">
<dt>local fields=&#8221;LOCAL_DIR</dt>
<dd>LOCAL_CONFIG_FILE
MODULES_DIR
SQLCA
DRM_DB
DBM_HISTORY
DRM_PROFILE
DRM_PROFILES_PATH</dd>
</dl>
<p>&#8220;</p>
<dl class="docutils">
<dt>if [[ ! -z &#8220;$SQLCA&#8221;  &amp;&amp; &#8220;$SQLCA&#8221; =~ .*mariadb.* ]] ; then</dt>
<dd><dl class="first docutils">
<dt>fields=&#8221;${fields}</dt>
<dd>MARIADB_USER
MARIADB_PWD
MARIADB_DB
MARIADB_HOST
MARIADB_DIR
MARIADB_TMZ
MARIADB_COMPILE_FILES_EXCLUDED
MARIADB_EXTRA_OPTIONS
MARIADB_ENABLE_COMMENTS</dd>
</dl>
<p class="last">&#8220;</p>
</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>if [[ ! -z &#8220;$SQLCA&#8221;  &amp;&amp; &#8220;$SQLCA&#8221; =~ .*sqlite.* ]] ; then</dt>
<dd><dl class="first docutils">
<dt>fields=&#8221;${fields}</dt>
<dd>SQLITEDB</dd>
</dl>
<p class="last">&#8220;</p>
</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>if [[ ! -z &#8220;$SQLCA&#8221;  &amp;&amp; &#8220;$SQLCA&#8221; =~ .*oracle.* ]] ; then</dt>
<dd><dl class="first docutils">
<dt>fields=&#8221;${fields}</dt>
<dd>ORACLE_USER
ORACLE_PWD
ORACLE_SID
ORACLE_DIR
ORACLE_COMPILE_FILES_EXCLUDED
TNS_ADMIN</dd>
</dl>
<p class="last">&#8220;</p>
</dd>
</dl>
<p>fi</p>
<p># TODO: use output modules.
for i in $fields ; do</p>
<blockquote>
<div>echo -en &#8220;$i = ${!i}n&#8221;</div></blockquote>
<p>done</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_info_end</p>
<p># dbm_dbm_initenv
dbm_initenv () {</p>
<blockquote>
<div><p>local ans=0
local v=&#8221;&#8221;
local dbrm_profiles_options=&#8221;&#8220;</p>
<p>shift 2</p>
<p>_dbm_check_initenv_args &#8220;$&#64;&#8221; || return 1</p>
<dl class="docutils">
<dt>if [ -f $DBM_INIT_DIR/dbrm.conf ] ; then</dt>
<dd>out_handler_print &#8220;File dbrm.conf is already present. I do nothing.&#8221;
ans=1</dd>
</dl>
<p>else</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ -e $DBM_INIT_DIR/dbrm.db ] ; then</dt>
<dd>out_handler_print &#8220;File $DBM_INIT_DIR/dbrm.db already exits.&#8221;
return 1</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>cp $CONFIG_FILE_STUB $DBM_INIT_DIR/dbrm.conf || error_handled </dt>
<dd>&#8220;Unexpected error on copy dbrm.conf stub file to local directory.&#8221;</dd>
</dl>
<p>if [ $DBM_INIT_PROFILES -eq 1 ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ -d ${DBM_INIT_DIR}/dbrm-profiles ] ; then</dt>
<dd><dl class="first docutils">
<dt>out_handler_print </dt>
<dd>&#8220;Profiles directory ${DBM_INIT_DIR}/dbrm-profiles already exits. I do nothing.&#8221;</dd>
</dl>
<p class="last">return 1</p>
</dd>
</dl>
<p>fi</p>
<p># Create profiles directory
mkdir ${DBM_INIT_DIR}/dbrm-profiles || error_handled </p>
<blockquote>
<div>&#8220;Error on create ${DBM_INIT_DIR}/dbrm-profiles directory.&#8221;</div></blockquote>
<p>dbrm_profiles_options=&#8221;DRM_PROFILE=1</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>DRM_PROFILES_PATH=${LOCAL_DIR}/dbrm-profiles
&#8220;</p>
<blockquote>
<div><p>fi</p>
<p>v=&#8221;# Database Release Manager configuration file</p>
</div></blockquote>
<p>LOCAL_DIR=${DBM_INIT_DIR}
LOCAL_CONFIG_FILE=${LOCAL_DIR}/dbrm.conf
LOGFILE=${LOCAL_DIR}/dbrm.log
DRM_DB=${DBM_INIT_DIR}/dbrm.db
${dbrm_profiles_options}
&#8220;</p>
<blockquote>
<div><blockquote>
<div><p># Create dbrm file
echo -en &#8220;${v}&#8221; &gt; ${DBM_INIT_DIR}/dbrm.conf</p>
<p>. ${DBM_INIT_DIR}/dbrm.conf</p>
<p># Create an empty database
_sqlite_create -c &#8220;$DRM_DB&#8221; -s &#8220;$dbm_schema&#8221; || </p>
<blockquote>
<div>error_handled &#8220;Error on create $DRM_DB file.&#8221;</div></blockquote>
<dl class="docutils">
<dt>_dbm_exts_check_extensions &#8220;0&#8221; || </dt>
<dd>error_handled &#8220;Error on initialize extensions.&#8221;</dd>
<dt>if [ $DBM_INIT_PROFILES -eq 1 ] ; then</dt>
<dd><p class="first"># Create dev.conf profile file
cp $CONFIG_FILE_STUB ${DBM_INIT_DIR}/dbrm-profiles/dev.conf || error_handled </p>
<blockquote>
<div>&#8220;Unexpected error on copy dbrm.conf stub file to dev.conf profile file.&#8221;</div></blockquote>
<p># Insert dev profile to DRM db.
dbm_add_profile &#8220;dbrm&#8221; &#8220;add_profile&#8221; &#8220;&#8211;name&#8221; &#8220;develop&#8221; &#8220;&#8211;file&#8221; &#8220;dev.conf&#8221; &#8220;&#8211;default&#8221; ||</p>
<blockquote>
<div>error_handled &#8220;Error on add default profile.&#8221;</div></blockquote>
<dl class="last docutils">
<dt>out_handler_print </dt>
<dd>&#8220;Directory is now initialized.nModify dev.conf file under dbrm-profile directory for complete configuration.&#8221;</dd>
</dl>
</dd>
</dl>
<p>else</p>
<blockquote>
<div><dl class="docutils">
<dt>out_handler_print </dt>
<dd>&#8220;Directory is now initialized.nModify dbrm.conf file for complete configuration.&#8221;</dd>
</dl>
</div></blockquote>
<p>fi</p>
</div></blockquote>
<p>fi</p>
<p>return $ans</p>
</div></blockquote>
<p>}
# dbm_dbm_initenv_end</p>
<p># dbm_dbm_shell
dbm_shell () {</p>
<blockquote>
<div><p>shift 2</p>
<p>_sqlite_shell -c &#8220;$DRM_DB&#8221; || error_handled &#8220;&#8221;</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_shell_end
#***</p>
<p># dbm_dbm_show_profiles
dbm_show_profiles () {</p>
<blockquote>
<div><p>_dbm_how_many_profiles || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_profiles=$_sqlite_ans
local query=&#8221;&#8221;
local counter=1
local id_profile=&#8221;&#8221;
local name=&#8221;&#8221;
local file=&#8221;&#8221;
local default_profile=&#8221;&#8221;
local update_date=&#8221;&#8221;
local creation_date=&#8221;&#8220;</p>
<p>[[ $DEBUG &amp;&amp; $DEBUG == true ]] &amp;&amp; echo -en &#8220;N. Profiles: $n_profilesn&#8221;</p>
<p>if [ x$n_profiles != x0 ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>query=&#8221;</dt>
<dd><dl class="first docutils">
<dt>SELECT id_profile,</dt>
<dd>profile_name,
default_profile,
conf_file,
creation_date,
update_date</dd>
</dl>
<p class="last">FROM Profiles
ORDER BY id_profile&#8221;</p>
</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID&#8221;
out_headers[1]=&#8221;PROFILE_NAME&#8221;
out_headers[2]=&#8221;DEFAULT&#8221;
out_headers[3]=&#8221;CONFIG_FILE&#8221;
out_headers[4]=&#8221;CREATION_DATE&#8221;
out_headers[5]=&#8221;UPDATE_DATE&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;34m&#8221;
out_el_pre[2]=&#8221;e[1;35m&#8221;
out_el_pre[3]=&#8221;e[1;36m&#8221;
out_el_pre[4]=&#8221;e[1;31m&#8221;
out_el_pre[5]=&#8221;e[1;32m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;10&#8221;
out_tabs[1]=&#8221;23&#8221;
out_tabs[2]=&#8221;15&#8221;
out_tabs[3]=&#8221;23&#8221;
out_tabs[4]=&#8221;23&#8221;
out_tabs[5]=&#8221;23&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>id_profile=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
name=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
default_profile=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`
file=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[4]}&#8217;`
update_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[5]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[6]}&#8217;`</p>
<dl class="docutils">
<dt>if [ x${default_profile} == x1 ] ; then</dt>
<dd>default_profile=&#8221;*&#8221;</dd>
<dt>else</dt>
<dd>default_profile=&#8221; &#8220;</dd>
</dl>
<p>fi</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_profile}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${name}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${default_profile}&#8221;&#8221;
eval &#8220;row${counter}[3]=&#8221;${file}&#8221;&#8221;
eval &#8220;row${counter}[4]=&#8221;${update_date}&#8221;&#8221;
eval &#8220;row${counter}[5]=&#8221;${creation_date}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div>out_handler_print &#8220;No profiles available.&#8221;</div></blockquote>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_profiles</p>
<p># dbm_dbm_show_releases
dbm_show_releases () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM Releases&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_rel=$_sqlite_ans
local id_release=&#8221;&#8221;
local name=&#8221;&#8221;
local version=&#8221;&#8221;
local release_date=&#8221;&#8221;
local creation_date=&#8221;&#8221;
local update_date=&#8221;&#8221;
local id_order=&#8221;&#8221;
local db_adapter=&#8221;&#8221;
local id_branch=&#8221;&#8221;
local directory=&#8221;&#8221;
local result=1
local query=&#8221;&#8221;
local counter=1</p>
<p>shift 2</p>
<p>_dbm_show_rel_args &#8220;$&#64;&#8221; || return $result</p>
<dl class="docutils">
<dt>query=&#8221;</dt>
<dd><dl class="first docutils">
<dt>SELECT id_release,</dt>
<dd>name,
version,
release_date,
creation_date,
update_date,
id_order,
db_adapter,
id_branch,
directory</dd>
</dl>
<p class="last">FROM Releases &#8220;</p>
</dd>
</dl>
<p>if [ -n &#8220;$DBM_BRANCH_ID&#8221; ] ; then</p>
<blockquote>
<div>query=&#8221;$query WHERE id_branch = $DBM_BRANCH_ID&#8221;</div></blockquote>
<p>fi</p>
<p>query=&#8221;$query ORDER BY id_order,id_branch ASC&#8221;</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. Releases: $n_reln&#8221;</p>
<p>if [ x$n_rel != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID&#8221;
out_headers[1]=&#8221;RELEASE_DATE&#8221;
out_headers[2]=&#8221;VERSION&#8221;
out_headers[3]=&#8221;UPDATE_DATE&#8221;
out_headers[4]=&#8221;ADAPTER&#8221;
out_headers[5]=&#8221;ID_ORDER&#8221;
out_headers[6]=&#8221;BRANCH&#8221;
out_headers[7]=&#8221;DIRECTORY&#8221;
out_headers[8]=&#8221;NAME&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;34m&#8221;
out_el_pre[2]=&#8221;e[1;35m&#8221;
out_el_pre[3]=&#8221;e[1;36m&#8221;
out_el_pre[4]=&#8221;e[1;31m&#8221;
out_el_pre[5]=&#8221;e[1;32m&#8221;
out_el_pre[6]=&#8221;e[1;38m&#8221;
out_el_pre[7]=&#8221;e[1;33m&#8221;
out_el_pre[8]=&#8221;e[1;37m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;10&#8221;
out_tabs[1]=&#8221;23&#8221;
out_tabs[2]=&#8221;10&#8221;
out_tabs[3]=&#8221;23&#8221;
out_tabs[4]=&#8221;10&#8221;
out_tabs[5]=&#8221;10&#8221;
out_tabs[6]=&#8221;10&#8221;
out_tabs[7]=&#8221;11&#8221;
out_tabs[8]=&#8221;10&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>id_release=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
name=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
version=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`
release_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[4]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[5]}&#8217;`
update_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[6]}&#8217;`
id_order=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[7]}&#8217;`
db_adapter=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[8]}&#8217;`
id_branch=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[9]}&#8217;`
directory=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[10]}&#8217;`</p>
<p>#if [ ${#release_date} -eq 10 ] ; then
#  release_date_tab=&#8221;tt&#8221;
#else
#  release_date_tab=&#8221;t&#8221;
#fi</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_release}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${release_date}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${version}&#8221;&#8221;
eval &#8220;row${counter}[3]=&#8221;${update_date}&#8221;&#8221;
eval &#8220;row${counter}[4]=&#8221;${db_adapter}&#8221;&#8221;
eval &#8220;row${counter}[5]=&#8221;${id_order}&#8221;&#8221;
eval &#8220;row${counter}[6]=&#8221;${id_branch}&#8221;&#8221;
eval &#8220;row${counter}[7]=&#8221;${directory}&#8221;&#8221;
eval &#8220;row${counter}[8]=&#8221;${name}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div>out_handler_print &#8220;No releases available.&#8221;</div></blockquote>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_releases_end</p>
<p># dbm_dbm_show_scripts
dbm_show_scripts () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM Scripts&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_s=$_sqlite_ans
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. Scripts: $n_sn&#8221;</p>
<p>if [ x$n_s != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT id_script,filename,type,active,directory,id_release,id_order,creation_date,update_date FROM Scripts ORDER BY id_release,id_order ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID&#8221;
out_headers[1]=&#8221;TYPE&#8221;
out_headers[2]=&#8221;ACTIVE&#8221;
out_headers[3]=&#8221;DIRECTORY&#8221;
out_headers[4]=&#8221;ID_RELEASE&#8221;
out_headers[5]=&#8221;ID_ORDER&#8221;
out_headers[6]=&#8221;UPDATE_DATE&#8221;
out_headers[7]=&#8221;FILENAME&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;35m&#8221;
out_el_pre[2]=&#8221;e[1;36m&#8221;
out_el_pre[3]=&#8221;e[1;31m&#8221;
out_el_pre[4]=&#8221;e[1;37m&#8221;
out_el_pre[5]=&#8221;e[1;32m&#8221;
out_el_pre[6]=&#8221;e[1;33m&#8221;
out_el_pre[7]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;10&#8221;
out_tabs[1]=&#8221;15&#8221;
out_tabs[2]=&#8221;10&#8221;
out_tabs[3]=&#8221;20&#8221;
out_tabs[4]=&#8221;12&#8221;
out_tabs[5]=&#8221;10&#8221;
out_tabs[6]=&#8221;24&#8221;
out_tabs[7]=&#8221;10&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>id_script=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
filename=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
s_type=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`
active=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[4]}&#8217;`
directory=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[5]}&#8217;`
id_release=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[6]}&#8217;`
id_order=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[7]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[8]}&#8217;`
update_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[9]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_script}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${s_type}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${active}&#8221;&#8221;
eval &#8220;row${counter}[3]=&#8221;${directory}&#8221;&#8221;
eval &#8220;row${counter}[4]=&#8221;${id_release}&#8221;&#8221;
eval &#8220;row${counter}[5]=&#8221;${id_order}&#8221;&#8221;
eval &#8220;row${counter}[6]=&#8221;${update_date}&#8221;&#8221;
eval &#8220;row${counter}[7]=&#8221;${filename}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No scripts available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_scripts_end</p>
<p># dbm_dbm_show_script_types
dbm_show_script_types () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM ScriptTypes&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_st=$_sqlite_ans
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. ScriptTypes: $n_stn&#8221;</p>
<p>if [ x$n_st != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT code,descr FROM ScriptTypes ORDER BY code ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;CODE&#8221;
out_headers[1]=&#8221;DESCRIPTION&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;20&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>code=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
descr=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${code}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${descr}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No script types available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_show_script_types_end</p>
<p># dbm_dbm_show_rel_dep
dbm_show_rel_dep () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM ReleasesDependencies&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_rd=$_sqlite_ans
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. ReleasesDependencies: $n_rdn&#8221;</p>
<p>if [ x$n_rd != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT id_release,id_release_dep,creation_date FROM ReleasesDependencies ORDER BY id_release,id_release_dep ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID_RELEASE&#8221;
out_headers[1]=&#8221;DEPENDENCY&#8221;
out_headers[2]=&#8221;CREATION_DATE&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;32m&#8221;
out_el_pre[2]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;15&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>id_release=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
id_release_dep=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_release}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${id_release_dep}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${creation_date}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No release dependencies available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_rel_dep</p>
<p># dbm_dbm_show_inhibit_scripts
dbm_show_inhibit_scripts () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM ScriptRelInhibitions&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_r=$_sqlite_ans
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. ScriptRelInhibitions: $n_rn&#8221;</p>
<p>if [ x$n_r != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT id_script,id_release_from,id_release_to,creation_date FROM ScriptRelInhibitions ORDER BY id_script,id_release_to,id_release_from ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID_SCRIPT&#8221;
out_headers[1]=&#8221;ID_RELEASE_FROM&#8221;
out_headers[2]=&#8221;ID_RELEASE_TO&#8221;
out_headers[3]=&#8221;CREATION_DATE&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;32m&#8221;
out_el_pre[2]=&#8221;e[1;31m&#8221;
out_el_pre[3]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;16&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>id_script=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
id_release_from=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
id_release_to=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[4]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_script}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${id_release_from}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${id_release_to}&#8221;&#8221;
eval &#8220;row${counter}[3]=&#8221;${creation_date}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No scripts available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_inhibit_scripts_end</p>
<p># dbm_dbm_show_rel_ded_scripts
dbm_show_rel_ded_scripts () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM ScriptRelDedicated&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_r=$_sqlite_ans
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. ScriptRelDedicated: $n_rn&#8221;</p>
<p>if [ x$n_r != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT id_script,id_release_from,id_release_to,creation_date FROM ScriptRelDedicated ORDER BY id_script,id_release_to,id_release_from ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID_SCRIPT&#8221;
out_headers[1]=&#8221;ID_RELEASE_FROM&#8221;
out_headers[2]=&#8221;ID_RELEASE_TO&#8221;
out_headers[3]=&#8221;CREATION_DATE&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;32m&#8221;
out_el_pre[2]=&#8221;e[1;31m&#8221;
out_el_pre[3]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;15&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>id_script=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
id_release_from=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
id_release_to=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[4]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_script}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${id_release_from}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${id_release_to}&#8221;&#8221;
eval &#8220;row${counter}[3]=&#8221;${creation_date}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No scripts available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_rel_ded_scripts_end</p>
<p># dbm_dbm_show_adapters
dbm_show_adapters  () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM DatabaseAdapters&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_st=$_sqlite_ans
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. ScriptTypes: $n_stn&#8221;</p>
<p>if [ x$n_st != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT adapter,descr FROM DatabaseAdapters ORDER BY adapter ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ADAPTER&#8221;
out_headers[1]=&#8221;DESCRIPTION&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;15&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>adapter=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
descr=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${adapter}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${descr}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No adapters available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_adapters_end</p>
<p># dbm_dbm_move_release
dbm_move_release () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_rel_to=&#8221;&#8221;
local id_rel_from=&#8221;&#8221;
local id_order=&#8221;&#8221;
local id_order_to=&#8221;&#8221;
local id_branch=&#8221;&#8221;
local id_branch_to=&#8221;&#8221;
local create_tmp_table=&#8221;&#8221;
local where_moved_record=&#8221;&#8221;
local insert2tmp=&#8221;&#8221;
local delete_rel=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_move_release_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm move_release $args&#8221;</p>
<p>_dbm_check_if_exist_rel &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_TO&#8221; || return $result
_dbm_check_if_exist_rel &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_FROM&#8221; || return $result</p>
<p># Retrive id order of the release from
_dbm_retrieve_field_rel &#8220;id_order&#8221; &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_FROM&#8221;
id_order=$_sqlite_ans</p>
<p># Retrieve id order of the release to
_dbm_retrieve_field_rel &#8220;id_order&#8221; &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_TO&#8221;
id_order_to=$_sqlite_ans</p>
<p># Retrieve id release from
_dbm_retrieve_field_rel &#8220;id_release&#8221; &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_FROM&#8221;
id_rel_from=$_sqlite_ans</p>
<p># Retrieve id release to
_dbm_retrieve_field_rel &#8220;id_release&#8221; &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_TO&#8221;
id_rel_to=$_sqlite_ans</p>
<p># Retrieve id branch from
_dbm_retrieve_field_rel &#8220;id_branch&#8221; &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_FROM&#8221;
id_branch=$_sqlite_ans</p>
<p># Retrieve id branch to
_dbm_retrieve_field_rel &#8220;id_branch&#8221; &#8220;$DBM_REL_NAME&#8221; &#8220;$DBM_REL_VERSION_TO&#8221;
id_branch_to=$_sqlite_ans</p>
<dl class="docutils">
<dt>if [ $id_branch_to -ne $id_branch ] ; then</dt>
<dd>error_generate &#8220;move_release command is not possibile between releases of different branches&#8221;</dd>
</dl>
<p>fi</p>
<p>_dbm_get_table_schema &#8216;Releases&#8217;
create_tmp_table=&#8221;$(echo &#8220;$_sqlite_ans&#8221; | sed &#8216;s/Releases/ReleasesTemp/&#8217;)&#8221;</p>
<p>if [ $DBM_AFTER -eq 1 ] ; then</p>
<blockquote>
<div><p>if [ $id_order_to -lt $id_order ] ; then</p>
<blockquote>
<div><p>where_moved_record=&#8221;WHERE id_branch = $id_branch AND ( id_order &gt; $id_order_to AND id_order &lt; $id_order )&#8221;</p>
<dl class="docutils">
<dt>insert2tmp=&#8221;INSERT INTO ReleasesTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_release,</dt>
<dd>name,
version,
release_date,
creation_date,
update_date,
$id_order_to+1 as id_order,
db_adapter,
id_branch,
directory,
flag_dev</dd>
</dl>
<p>FROM Releases
WHERE id_release = $id_rel_from
AND id_branch = $id_branch ;
INSERT INTO ReleasesTemp
SELECT id_release,</p>
<blockquote>
<div>name,
version,
release_date,
creation_date,
update_date,
id_order+1 as id_order,
db_adapter,
id_branch,
directory,
flag_dev</div></blockquote>
<p class="last">FROM Releases $where_moved_record &#8220;</p>
</dd>
</dl>
<p># POST: Move yet release_from to Temporary table</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div><p>where_moved_record=&#8221;WHERE id_order &gt; $id_order AND id_branch = $id_branch &#8221;
# POST: Move yet release_from to Temporary table</p>
<dl class="docutils">
<dt>insert2tmp=&#8221;INSERT INTO ReleasesTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_release,</dt>
<dd>name,
version,
release_date,
creation_date,
update_date,
id_order-1 as id_order,
db_adapter,
id_branch,
directory,
flag_dev</dd>
</dl>
<p>FROM Releases
WHERE id_branch = $id_branch
AND id_order &gt; $id_order AND id_order &lt;= $id_order_to ;
INSERT INTO ReleasesTemp
SELECT id_release,</p>
<blockquote>
<div>name,
version,
release_date,
creation_date,
update_date,
id_order as id_order,
db_adapter,
id_branch,
directory,
flag_dev</div></blockquote>
<p>FROM Releases
WHERE id_order &gt; $id_order_to AND id_branch = $id_branch ;
INSERT INTO ReleasesTemp
SELECT id_release,</p>
<blockquote>
<div>name,
version,
release_date,
creation_date,
update_date,
$id_order_to as id_order,
db_adapter,
id_branch,
directory,
flag_dev</div></blockquote>
<p class="last">FROM Releases
WHERE id_release = $id_rel_from
AND id_branch = $id_branch &#8220;</p>
</dd>
</dl>
</div></blockquote>
<p>fi</p>
<p>t=&#8221;after&#8221;</p>
<p>result=0</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div><p>if [ $id_order_to -lt $id_order ] ; then</p>
<blockquote>
<div><p>where_moved_record=&#8221;WHERE id_branch = $id_branch AND id_order &lt; $id_order AND id_order &gt;= $id_order_to &#8220;</p>
<dl class="docutils">
<dt>insert2tmp=&#8221;INSERT INTO ReleasesTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_release,</dt>
<dd>name,
version,
release_date,
creation_date,
update_date,
id_order+1 as id_order,
db_adapter,
id_branch,
directory,
flag_dev</dd>
</dl>
<p>FROM Releases $where_moved_record ;
INSERT INTO ReleasesTemp
SELECT id_release,</p>
<blockquote>
<div>name,
version,
release_date,
creation_date,
update_date,
$id_order_to as id_order,
db_adapter,
id_branch,
directory,
flag_dev</div></blockquote>
<p class="last">FROM Releases
WHERE id_release = $id_rel_from AND id_branch = $id_branch &#8220;</p>
</dd>
</dl>
<p># POST: Move yet release_from to Temporary table</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div><p>where_moved_record=&#8221;WHERE id_branch = $id_branch AND id_order &lt; $id_order_to AND id_order &gt; $id_order &#8220;</p>
<dl class="docutils">
<dt>insert2tmp=&#8221;INSERT INTO ReleasesTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_release,</dt>
<dd>name,
version,
release_date,
creation_date,
update_date,
id_order-1 as id_order,
db_adapter,
id_branch,
directory,
flag_dev</dd>
</dl>
<p>FROM Releases $where_moved_record ;
INSERT INTO ReleasesTemp
SELECT id_release,</p>
<blockquote>
<div>name,
version,
release_date,
creation_date,
update_date,
$id_order_to-1 as id_order,
db_adapter,
id_branch,
directory,
flag_dev</div></blockquote>
<p class="last">FROM Releases
WHERE id_release = $id_rel_from AND id_branch = $id_branch &#8220;</p>
</dd>
</dl>
<p># POST: Move yet release_from to Temporary table</p>
</div></blockquote>
<p>fi</p>
<p>t=&#8221;before&#8221;
result=0</p>
</div></blockquote>
<p>fi</p>
<p>delete_rel=&#8221;DELETE FROM Releases $where_moved_record OR (id_order = $id_order AND id_branch = $id_branch)&#8221;</p>
<p># Disable PRAGMA options
SQLITEDB_INIT_SESSION=&#8221; &#8220;</p>
<dl class="docutils">
<dt>query=&#8221;DROP TABLE IF EXISTS ReleasesTemp ;</dt>
<dd><p class="first">$create_tmp_table ;
${insert2tmp} ;
${delete_rel} ;
INSERT INTO Releases</p>
<blockquote>
<div><dl class="docutils">
<dt>SELECT id_release,</dt>
<dd>name,
version,
release_date,
creation_date,
DATETIME(&#8216;now&#8217;),
id_order,
db_adapter,
id_branch,
directory,
flag_dev</dd>
</dl>
<p>FROM ReleasesTemp;</p>
</div></blockquote>
<p class="last">DROP TABLE ReleasesTemp &#8220;</p>
</dd>
</dl>
<p>#  SELECT * FROM ReleasesTemp ;
#  SELECT &#8216;-&#8216;  ;
#  SELECT * FROM Releases ;
_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error on update id_order fields.&#8221;</p>
<p># Re-enable PRAGMA options
unset SQLITEDB_INIT_SESSION</p>
<p>echo -en &#8220;Moved correctly $DBM_REL_NAME v.$DBM_REL_VERSION_FROM ${t} v.$DBM_REL_VERSION_TO.n&#8221;</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_move_release_end</p>
<p># dbm_dbm_update_release
dbm_update_release () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;UPDATE Releases SET &#8221;
local count=0
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_upd_release_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm update_release $args&#8221;</p>
<p>if [ -n &#8220;$DBM_REL_NAME&#8221; ] ; then</p>
<blockquote>
<div>query=&#8221;$query name = &#8216;${DBM_REL_NAME}&#8217;&#8221;
let count++</div></blockquote>
<p>fi</p>
<p>if [ -n &#8220;$DBM_REL_DATE&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $count -eq 0 ] ; then</dt>
<dd>query=&#8221;$query release_date = &#8216;${DBM_REL_DATE}&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query=&#8221;$query , release_date = &#8216;${DBM_REL_DATE}&#8217;&#8221;</dd>
</dl>
<p>fi
let count++</p>
</div></blockquote>
<p>fi</p>
<p>if [ -n &#8220;$DBM_REL_VERSION&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $count -eq 0 ] ; then</dt>
<dd>query=&#8221;$query version = &#8216;${DBM_REL_VERSION}&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query=&#8221;$query , version = &#8216;${DBM_REL_VERSION}&#8217;&#8221;</dd>
</dl>
<p>fi
let count++</p>
</div></blockquote>
<p>fi</p>
<p>if [ -n &#8220;$DBM_REL_ADAPTER&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $count -eq 0 ] ; then</dt>
<dd>query=&#8221;$query db_adapter = &#8216;${DBM_REL_ADAPTER}&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query=&#8221;$query , db_adapter = &#8216;${DBM_REL_ADAPTER}&#8217;&#8221;</dd>
</dl>
<p>fi
let count++</p>
</div></blockquote>
<p>fi</p>
<p>if [ -n &#8220;$DBM_REL_BRANCH&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $count -eq 0 ] ; then</dt>
<dd>query=&#8221;$query id_branch = ${DBM_REL_BRANCH}&#8221;</dd>
<dt>else</dt>
<dd>query=&#8221;$query , id_branch = ${DBM_REL_BRANCH}&#8221;</dd>
</dl>
<p>fi
let count++</p>
</div></blockquote>
<p>fi</p>
<p>if [ -n &#8220;$DBM_REL_DIR&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $count -eq 0 ] ; then</dt>
<dd>query=&#8221;$query directory = &#8216;${DBM_REL_DIR}&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query=&#8221;$query , directory = &#8216;${DBM_REL_DIR}&#8217;&#8221;</dd>
</dl>
<p>fi</p>
</div></blockquote>
<p>fi</p>
<p>query=&#8221;$query WHERE id_release = $DBM_REL_ID&#8221;</p>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Error on update release $DBM_REL_ID.&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Release $DBM_REL_ID updated correctly.&#8221;
result=0</dd>
</dl>
<p>fi</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_update_release_end</p>
<p># dbm_dbm_add_profile
dbm_add_profile () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_profile=&#8221;&#8221;
local is_present_default=0
local update_query=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_add_prof_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm add_profile $args&#8221;</p>
<p># Check if present a default profile
query=&#8221;</p>
<blockquote>
<div>SELECT COUNT(1)
FROM Profiles
WHERE default_profile = 1&#8221;</div></blockquote>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Error on check if is present a default profile&#8221;</p>
<dl class="docutils">
<dt>if [[ x&#8221;$_sqlite_ans&#8221; != x&#8221;0&#8221; &amp;&amp; $DBM_PROFILE_DEFAULT -eq 1 ]] ; then</dt>
<dd>is_present_default=1</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>if [ $is_present_default -eq 1 ] ; then</dt>
<dd><dl class="first last docutils">
<dt>update_query=&#8221;</dt>
<dd>UPDATE Profiles
SET default_profile = 0, update_date = DATETIME(&#8216;now&#8217;)
WHERE default_profile = 1&#8221;</dd>
</dl>
</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>query=&#8221;</dt>
<dd><p class="first">${update_query};
INSERT INTO Profiles
(profile_name,</p>
<blockquote>
<div>conf_file,
default_profile,
creation_date,
update_date)</div></blockquote>
<dl class="docutils">
<dt>VALUES (</dt>
<dd>&#8216;$DBM_PROFILE_NAME&#8217;,
&#8216;$DBM_PROFILE_FILENAME&#8217;,
&#8216;$DBM_PROFILE_DEFAULT&#8217;,
DATETIME(&#8216;now&#8217;),
DATETIME(&#8216;now&#8217;)</dd>
</dl>
<p class="last">);
SELECT last_insert_rowid() AS rowid
FROM Profiles
LIMIT 1</p>
</dd>
</dl>
<p>&#8220;</p>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Error on insert profile $DBM_PROFILE_NAME.&#8221;</p>
<dl class="docutils">
<dt>if [ -n &#8220;$_sqlite_ans&#8221; ] ; then</dt>
<dd>out_handler_print &#8220;Created profile $_sqlite_ans.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_add_profile_end</p>
<p># dbm_dbm_del_profile
dbm_del_profile () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local where_cond=&#8221;&#8221;
local profile=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_prof_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm del_profile $args&#8221;</p>
<dl class="docutils">
<dt>if [ $DBM_PROFILE_BYID -eq 1 ] ; then</dt>
<dd>where_cond=&#8221;id_profile = $DBM_PROFILE_ID&#8221;
profile=&#8221;$DBM_PROFILE_ID&#8221;</dd>
<dt>else</dt>
<dd>where_cond=&#8221;profile_name = &#8216;$DBM_PROFILE_NAME&#8217;&#8221;
profile=&#8221;$DBM_PROFILE_NAME&#8221;</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>query=&#8221;</dt>
<dd>DELETE FROM Profiles
WHERE ${where_cond}&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Error on delete profile.&#8221;</p>
<p>out_handler_print &#8220;Profile $profile is been deleted.&#8221;</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_del_profile_end</p>
<p># dbm_dbm_set_profile
dbm_set_profile () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local where_cond=&#8221;&#8221;
local profile=&#8221;&#8221;
local is_present_default=0
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_prof_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm set_profile $args&#8221;</p>
<p># Check if present a default profile
query=&#8221;</p>
<blockquote>
<div>SELECT COUNT(1)
FROM Profiles
WHERE default_profile = 1&#8221;</div></blockquote>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Error on check if is present a default profile&#8221;</p>
<dl class="docutils">
<dt>if [ x&#8221;$_sqlite_ans&#8221; != x&#8221;0&#8221; ] ; then</dt>
<dd>is_present_default=1</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>if [ $is_present_default -eq 1 ] ; then</dt>
<dd><dl class="first last docutils">
<dt>update_query=&#8221;</dt>
<dd>UPDATE Profiles
SET default_profile = 0, update_date = DATETIME(&#8216;now&#8217;)
WHERE default_profile = 1&#8221;</dd>
</dl>
</dd>
</dl>
<p>fi</p>
<p>if [ $DBM_PROFILE_BYID -eq 1 ] ; then</p>
<blockquote>
<div>where_cond=&#8221;id_profile = $DBM_PROFILE_ID&#8221;
profile=&#8221;$DBM_PROFILE_ID&#8221;
_dbm_check_if_exist_prof_byid &#8220;$profile&#8221; || error_handled &#8220;&#8221;</div></blockquote>
<p>else</p>
<blockquote>
<div>where_cond=&#8221;profile_name = &#8216;$DBM_PROFILE_NAME&#8217;&#8221;
profile=&#8221;$DBM_PROFILE_NAME&#8221;
_dbm_check_if_exist_prof_byname &#8220;$profile&#8221; || error_handled &#8220;&#8221;</div></blockquote>
<p>fi</p>
<dl class="docutils">
<dt>query=&#8221;</dt>
<dd>${update_query};
UPDATE Profiles
SET default_profile = 1, update_date = DATETIME(&#8216;now&#8217;)
WHERE ${where_cond}&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Error on set profile $profile.&#8221;</p>
<p>out_handler_print &#8220;Profile $profile is now set as default.&#8221;</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_set_profile_end</p>
<p># dbm_dbm_insert_release
dbm_insert_release () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_branch=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_ins_rel_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_release $args&#8221;</p>
<p>if [ -z &#8220;$DBM_REL_BRANCH&#8221; ] ; then</p>
<blockquote>
<div>id_branch=&#8221;(SELECT id_branch FROM Branches WHERE name = &#8216;master&#8217;)&#8221;</div></blockquote>
<p>else</p>
<blockquote>
<div>_dbm_check_if_exist_id_branch &#8220;$DBM_REL_BRANCH&#8221;
id_branch=&#8221;$DBM_REL_BRANCH&#8221;</div></blockquote>
<p>fi</p>
<p>if [ -z &#8220;$DBM_REL_ORDER&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>query=&#8221;INSERT INTO Releases</dt>
<dd><dl class="first docutils">
<dt>(name,version,release_date,db_adapter,creation_date,</dt>
<dd>update_date,id_order, id_branch,directory)</dd>
</dl>
<p>VALUES
(&#8216;$DBM_REL_NAME&#8217;, &#8216;$DBM_REL_VERSION&#8217; ,$DBM_REL_DATE,&#8217;$DBM_REL_ADAPTER&#8217;,DATETIME(&#8216;now&#8217;),</p>
<blockquote class="last">
<div><p>DATETIME(&#8216;now&#8217;),
(SELECT T.ID FROM (</p>
<blockquote>
<div>SELECT MAX(id_order)+1 AS ID, 1 AS T from Releases
WHERE id_branch = $id_branch
UNION SELECT 1 AS ID, 0 AS T
) T</div></blockquote>
<p>WHERE ID IS NOT NULL ORDER BY T.T DESC LIMIT 1),
$id_branch, &#8216;$DBM_REL_DIR&#8217;)&#8221;</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd><dl class="first last docutils">
<dt>query=&#8221;INSERT INTO Releases</dt>
<dd><dl class="first docutils">
<dt>(name,version,release_date,db_adapter,creation_date,</dt>
<dd>update_date,id_order, id_branch,directory)</dd>
</dl>
<p>VALUES
(&#8216;$DBM_REL_NAME&#8217;,&#8217;$DBM_REL_VERSION&#8217;,$DBM_REL_DATE,&#8217;$DBM_REL_ADAPTER&#8217;,DATETIME(&#8216;now&#8217;),</p>
<blockquote class="last">
<div>DATETIME(&#8216;now&#8217;), $DBM_REL_ORDER, $id_branch, &#8216;$DBM_REL_DIR&#8217;)&#8221;</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>fi</p>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Release $DBM_REL_NAME v. $DBM_REL_VERSION insert correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_release</p>
<p># dbm_remove_release
dbm_remove_release () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_branch=&#8221;&#8221;
local cnt=&#8221;&#8221;
local cofirm=0</p>
<p># Shift first two input param
shift 2</p>
<p>_dbm_check_rem_rel_args &#8220;$&#64;&#8221; || return $result</p>
<p># Retrive id branch of the release
_dbm_retrieve_field_rel_byid &#8220;id_branch&#8221; &#8220;$DBM_REL_ID&#8221;
id_branch=$_sqlite_ans</p>
<p># Check if there is some dependency with release
query=&#8221;SELECT count(1) AS CNT</p>
<blockquote>
<div>FROM ReleasesDependencies
WHERE id_release_dep = $DBM_REL_ID&#8221;</div></blockquote>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error on check for dependencies&#8221;
cnt=$_sqlite_ans</p>
<p>if [ $cnt -ne 0 ] ; then</p>
<blockquote>
<div>error_handled &#8220;There are dependencies with release $DBM_REL_ID. You must remove these dependencies before remove release $DBM_REL_ID.&#8221;</div></blockquote>
<p>fi</p>
<dl class="docutils">
<dt>if [ $DBM_FORCE_RM -eq 1 ] ; then</dt>
<dd>confirm=1</dd>
<dt>else</dt>
<dd><p class="first">confirmation_question &#8220;Are you sure to remove release with id $DBM_REL_ID? [N/y]&#8221;
if [ $? -eq 0 ] ; then</p>
<blockquote>
<div>confirm=1</div></blockquote>
<p class="last">fi</p>
</dd>
</dl>
<p>fi</p>
<p>if [ $confirm -eq 1 ] ; then</p>
<blockquote>
<div><p>_dbm_remove_all_scripts_rel_ded $DBM_REL_ID || error_handled &#8220;Unexpected error on remove all scripts from ScriptRelDedicated table&#8221;</p>
<p>_dbm_remove_all_scripts_rel_inhib  $DBM_REL_ID || error_handled &#8220;Unexpected error on remove all scripts from ScriptRelInhibitions table&#8221;</p>
<p>_dbm_remove_release $DBM_REL_ID || error_handled &#8220;Unexpected error on remove release with id $DBM_REL_ID.&#8221;</p>
<p>_dbm_update_idorder $id_branch || error_handled &#8220;Unexpected error on update id_order&#8221;</p>
<p>out_handler_print &#8220;Release $DBM_REL_ID is been removed.&#8221;</p>
</div></blockquote>
<p>fi</p>
<p>result=0</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_remove_release_end</p>
<p># dbm_dbm_remove_script
dbm_remove_script () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>_dbm_check_rm_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>query=&#8221;DELETE FROM ScriptRelInhibitions WHERE id_script = $DBM_SCRIPT_ID; DELETE FROM Scripts WHERE id_script = $DBM_SCRIPT_ID&#8221;</p>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Script $DBM_SCRIPT_ID removed correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_remove_script_end</p>
<p># dbm_dbm_update_script
dbm_update_script () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local query_sub=&#8221;&#8221;
local upd_elems=0
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_upd_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm update_script $args&#8221;</p>
<p>if [ ! -z &#8220;$DBM_SCRIPT_FILENAME&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET filename = &#8216;$DBM_SCRIPT_FILENAME&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, filename = &#8216;$DBM_SCRIPT_FILENAME&#8217;&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
<p>if [ ! -z &#8220;$DBM_SCRIPT_TYPE&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET type = &#8216;$DBM_SCRIPT_TYPE&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, type = &#8216;$DBM_SCRIPT_TYPE&#8217;&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
<p>if [ ! -z &#8220;$DBM_SCRIPT_ACTIVE&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET active = &#8216;$DBM_SCRIPT_ACTIVE&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, active = &#8216;$DBM_SCRIPT_ACTIVE&#8217;&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
<p>if [ ! -z &#8220;$DBM_SCRIPT_DIRECTORY&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET directory = &#8216;$DBM_SCRIPT_DIRECTORY&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, directory = &#8216;$DBM_SCRIPT_DIRECTORY&#8217;&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
<p>if [ -z &#8220;$DBM_SCRIPT_ID_RELEASE&#8221; ] ; then</p>
<blockquote>
<div><p>if [[ ! -z &#8220;$DBM_SCRIPT_REL_VERSION&#8221; &amp;&amp; ! -z &#8220;$DBM_SCRIPT_REL_NAME&#8221; ]] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>id_rel_query=&#8221;(SELECT id_release FROM Releases </dt>
<dd>WHERE name = &#8216;$DBM_SCRIPT_REL_NAME&#8217; AND version = &#8216;$DBM_SCRIPT_REL_VERSION&#8217;)&#8221;</dd>
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET id_release = $id_rel_query&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, id_release = $id_rel_query&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET id_release = &#8216;$DBM_SCRIPT_ID_RELEASE&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, id_release = &#8216;$DBM_SCRIPT_ID_RELEASE&#8217;&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
<p>if [ ! -z &#8220;$DBM_SCRIPT_ID_ORDER&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [ $upd_elems -eq 0 ] ; then</dt>
<dd>query_sub=&#8221;SET id_order = &#8216;$DBM_SCRIPT_ID_ORDER&#8217;&#8221;</dd>
<dt>else</dt>
<dd>query_sub=&#8221;${query_sub}, id_order = &#8216;$DBM_SCRIPT_ID_ORDER&#8217;&#8221;</dd>
</dl>
<p>fi</p>
<p>let upd_elems++</p>
</div></blockquote>
<p>fi</p>
<p>if [ $upd_elems -gt 0 ] ; then</p>
<blockquote>
<div><p>query=&#8221;UPDATE Scripts ${query_sub}, update_date = DATETIME(&#8216;now&#8217;) WHERE id_script = $DBM_SCRIPT_ID&#8221;
_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Script $DBM_SCRIPT_ID updated correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div>echo -en &#8220;No elements to update for script $DBM_SCRIPT_ID.n&#8221;</div></blockquote>
<p>fi</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_update_script_end</p>
<p># dbm_dbm_insert_script
dbm_insert_script () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_rel_query=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_ins_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_script $args&#8221;</p>
<dl class="docutils">
<dt>if [ -z &#8220;$DBM_SCRIPT_ID_RELEASE&#8221; ] ; then</dt>
<dd>id_rel_query=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_SCRIPT_REL_NAME&#8217; AND version = &#8216;$DBM_SCRIPT_REL_VERSION&#8217;)&#8221;</dd>
<dt>else</dt>
<dd>id_rel_query=&#8221;$DBM_SCRIPT_ID_RELEASE&#8221;</dd>
</dl>
<p>fi</p>
<dl class="docutils">
<dt>query=&#8221;INSERT INTO Scripts (filename,type,active,directory,id_release,creation_date,update_date,id_order) </dt>
<dd>VALUES (&#8216;$DBM_SCRIPT_FILENAME&#8217;, &#8216;$DBM_SCRIPT_TYPE&#8217; ,$DBM_SCRIPT_ACTIVE,&#8217;$DBM_SCRIPT_DIRECTORY&#8217;, $id_rel_query, DATETIME(&#8216;now&#8217;),DATETIME(&#8216;now&#8217;),&#8221;</dd>
</dl>
<p>if [ -z &#8220;$DBM_SCRIPT_ID_ORDER&#8221; ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>query=&#8221;${query} (SELECT T.ID FROM </dt>
<dd>( SELECT MAX(ID_ORDER)+1 AS ID, 1 AS T FROM Scripts WHERE ID_RELEASE = $id_rel_query UNION SELECT 1 AS ID, 0 AS T ) T WHERE ID IS NOT NULL ORDER BY T.T DESC LIMIT 1))&#8221;</dd>
</dl>
</div></blockquote>
<p>else</p>
<blockquote>
<div>query=&#8221;${query} ${DBM_SCRIPT_ID_ORDER})&#8221;</div></blockquote>
<p>fi</p>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Script $DBM_SCRIPT_FILENAME insert correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_script_end</p>
<p># dbm_dbm_insert_script_type
dbm_insert_script_type () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_ins_script_type_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_script_type $args&#8221;</p>
<p>query=&#8221;INSERT INTO ScriptTypes (code,descr) VALUES (&#8216;$DBM_SCRIPT_TYPE_CODE&#8217;, &#8216;$DBM_SCRIPT_TYPE_DESCR&#8217;)&#8221;;</p>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Script Type $DBM_SCRIPT_TYPE_CODE insert correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_script_type_end</p>
<p># dbm_dbm_insert_rel_dep
dbm_insert_rel_dep () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_rel_query_to=&#8221;&#8221;
local id_rel_query_from=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_rel_dep_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_rel_dep $args&#8221;</p>
<p>id_rel_query_to=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_TO&#8217;)&#8221;
id_rel_query_from=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_FROM&#8217;)&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;INSERT INTO ReleasesDependencies (id_release,id_release_dep,creation_date) </dt>
<dd>VALUES (${id_rel_query_to}, ${id_rel_query_from}, DATETIME(&#8216;now&#8217;))&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Insert release dependency to $DBM_REL_NAME v.$DBM_REL_VERSION_TO correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_rel_dep</p>
<p># dbm_dbm_remove_rel_dep
dbm_remove_rel_dep () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_rel_query_to=&#8221;&#8221;
local id_rel_query_from=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>_dbm_check_rel_dep_args &#8220;$&#64;&#8221; || return $result</p>
<p>id_rel_query_to=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_TO&#8217;)&#8221;
id_rel_query_from=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_FROM&#8217;)&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;DELETE FROM ReleasesDependencies </dt>
<dd>WHERE id_release = ${id_rel_query_to} AND id_release_dep = ${id_rel_query_from}&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Remove release dependencty to $DBM_REL_NAME v.$DBM_REL_VERSION_TO with $DBM_REL_VERSION_FROM correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_remove_rel_dep_end</p>
<p># dbm_dbm_insert_inhibit_script
dbm_insert_inhibit_script () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_rel_query_to=&#8221;&#8221;
local id_rel_query_from=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_inhibit_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_inhibit_script $args&#8221;</p>
<p>id_rel_query_to=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_TO&#8217;)&#8221;
id_rel_query_from=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_FROM&#8217;)&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;INSERT INTO ScriptRelInhibitions (id_script,id_release_from,id_release_to,creation_date) </dt>
<dd>VALUES ($DBM_SCRIPT_ID, ${id_rel_query_from}, ${id_rel_query_to}, DATETIME(&#8216;now&#8217;))&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Record insert correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_inhibit_script_end</p>
<p># dbm_dbm_insert_ded_script
dbm_insert_ded_script () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local id_rel_query_to=&#8221;&#8221;
local id_rel_query_from=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_inhibit_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_ded_script $args&#8221;</p>
<p>id_rel_query_to=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_TO&#8217;)&#8221;
id_rel_query_from=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_FROM&#8217;)&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;INSERT INTO ScriptRelDedicated (id_script,id_release_from,id_release_to,creation_date) </dt>
<dd>VALUES ($DBM_SCRIPT_ID, ${id_rel_query_from}, ${id_rel_query_to}, DATETIME(&#8216;now&#8217;))&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Record insert correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_ded_script_end</p>
<p># dbm_dbm_remove_inhibit_script
dbm_remove_inhibit_script () {</p>
<blockquote>
<div><p>local result=1
local query=1
local id_rel_query_to=&#8221;&#8221;
local id_rel_query_from=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>_dbm_check_inhibit_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>id_rel_query_to=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_TO&#8217;)&#8221;
id_rel_query_from=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_FROM&#8217;)&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;DELETE FROM ScriptRelInhibitions </dt>
<dd>WHERE id_script = $DBM_SCRIPT_ID AND id_release_from = ${id_rel_query_from} AND id_release_to = ${id_rel_query_to}&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Record removed correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_remove_inhibit_script_end</p>
<p># dbm_dbm_remove_ded_script
dbm_remove_ded_script () {</p>
<blockquote>
<div><p>local result=1
local query=1
local id_rel_query_to=&#8221;&#8221;
local id_rel_query_from=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>_dbm_check_inhibit_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>id_rel_query_to=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_TO&#8217;)&#8221;
id_rel_query_from=&#8221;(SELECT id_release FROM Releases WHERE name = &#8216;$DBM_REL_NAME&#8217; AND version = &#8216;$DBM_REL_VERSION_FROM&#8217;)&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;DELETE FROM ScriptRelDedicated </dt>
<dd>WHERE id_script = $DBM_SCRIPT_ID AND id_release_from = ${id_rel_query_from} AND id_release_to = ${id_rel_query_to}&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Record removed correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_remove_ded_script_end</p>
<p># dbm_dbm_show_branches
dbm_show_branches () {</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT COUNT(1) AS R FROM Branches&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>local n_rec=$_sqlite_ans
local creation_date=&#8221;&#8221;
local update_date=&#8221;&#8221;
local counter=0</p>
<p>[[ $DEBUG ]] &amp;&amp; echo -en &#8220;N. Branches: $n_recn&#8221;</p>
<p>if [ x$n_rec != x0 ] ; then</p>
<blockquote>
<div><p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;SELECT id_branch,name,creation_date,update_date FROM Branches ORDER BY id_branch ASC&#8221; || error_handled &#8220;Unexpected error!&#8221;</p>
<p>out_hsep=1
out_prepost_mode=&#8221;any&#8221;
out_htabs_mode=&#8221;tabs&#8221;</p>
<p>out_headers[0]=&#8221;ID&#8221;
out_headers[1]=&#8221;CREATION_DATE&#8221;
out_headers[2]=&#8221;UPDATE_DATE&#8221;
out_headers[3]=&#8221;NAME&#8221;</p>
<p>out_el_pre[0]=&#8221;e[1;33m&#8221;
out_el_pre[1]=&#8221;e[1;32m&#8221;
out_el_pre[2]=&#8221;e[1;31m&#8221;
out_el_pre[3]=&#8221;e[1;34m&#8221;</p>
<p>out_el_post[0]=&#8221;e[m&#8221;</p>
<p>out_tabs[0]=&#8221;10&#8221;
out_tabs[1]=&#8221;24&#8221;
out_tabs[2]=&#8221;24&#8221;
out_tabs[3]=&#8221;10&#8221;</p>
<p>IFS=$&#8217;n&#8217;
for row in $_sqlite_ans ; do</p>
<blockquote>
<div><p>#[[ $DEBUG ]] &amp;&amp; echo &#8220;ROW = ${row}&#8221;</p>
<p>id_branch=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[1]}&#8217;`
name=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[2]}&#8217;`
creation_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[3]}&#8217;`
update_date=`echo $row | awk &#8216;{split($0,a,&#8221;|&#8221;); print a[4]}&#8217;`</p>
<p>out_rows[$counter]=&#8221;row&#8221;${counter}</p>
<p>eval &#8220;row${counter}[0]=&#8221;${id_branch}&#8221;&#8221;
eval &#8220;row${counter}[1]=&#8221;${creation_date}&#8221;&#8221;
eval &#8220;row${counter}[2]=&#8221;${update_date}&#8221;&#8221;
eval &#8220;row${counter}[3]=&#8221;${name}&#8221;&#8220;</p>
<p>let counter++</p>
</div></blockquote>
<p>done
unset IFS</p>
<p>out_handler_print_arr</p>
</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd>out_handler_print &#8220;No branches available.&#8221;</dd>
</dl>
<p>fi</p>
<p>out_handler_clean</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_show_branches</p>
<p># dbm_dbm_insert_branch
dbm_insert_branch () {</p>
<blockquote>
<div><p>local result=1
local query=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_ins_bra_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm insert_branch $args&#8221;</p>
<dl class="docutils">
<dt>query=&#8221;INSERT INTO Branches (name,creation_date,update_date) </dt>
<dd>VALUES (&#8216;$DBM_BRA_NAME&#8217;, DATETIME(&#8216;now&#8217;),DATETIME(&#8216;now&#8217;))&#8221;</dd>
</dl>
<p>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error!&#8221;
ans=$?</p>
<dl class="docutils">
<dt>if [ x&#8221;$ans&#8221; = x&#8221;0&#8221; ] ; then</dt>
<dd>echo &#8220;Branches $DBM_BRA_NAME insert correctly.&#8221;</dd>
</dl>
<p>fi</p>
<p>result=$ans</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_dbm_insert_branch_end</p>
<p># dbm_move_script
dbm_move_script () {</p>
<blockquote>
<div><p>local result=1
local id_order_from=&#8221;&#8221;
local id_order_to=&#8221;&#8221;
local create_tmp_table=&#8221;&#8221;
local move_others=&#8221;&#8221;
local args=&#8221;&#8220;</p>
<p># Shift first two input param
shift 2</p>
<p>args=&#8221;$&#64;&#8221;</p>
<p>_dbm_check_move_script_args &#8220;$&#64;&#8221; || return $result</p>
<p>_dbm_check_if_exist_id_rel &#8220;$DBM_REL_ID&#8221; || return $result</p>
<p>_dbm_check_if_exist_id_script &#8220;$DBM_SCRIPT_ID_FROM&#8221; &#8220;$DBM_REL_ID&#8221; || return $result</p>
<p>_dbm_check_if_exist_id_script &#8220;$DBM_SCRIPT_ID_TO&#8221; &#8220;$DBM_REL_ID&#8221; || return $result</p>
<p>_dbm_save2history &#8220;dbrm dbm move_script $args&#8221;</p>
<p>_dbm_retrieve_field_script &#8220;id_order&#8221; &#8220;$DBM_SCRIPT_ID_FROM&#8221;
id_order_from=$_sqlite_ans</p>
<p>_dbm_retrieve_field_script &#8220;id_order&#8221; &#8220;$DBM_SCRIPT_ID_TO&#8221;
id_order_to=$_sqlite_ans</p>
<p>if [ $DBM_AFTER -eq 1 ] ; then</p>
<blockquote>
<div><p>if  [ $id_order_to -lt $id_order_from ] ; then</p>
<blockquote>
<div><p>where_moved_record=&#8221;( id_order &gt; $id_order_to AND id_order &lt; $id_order_from )&#8221;</p>
<dl class="docutils">
<dt>insert2tmp=&#8221;INSERT INTO ScriptsTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_script, filename, type, active,</dt>
<dd>directory, id_release, $id_order_to+1 as id_order,
creation_date, update_date</dd>
</dl>
<p>FROM Scripts
WHERE id_script = $DBM_SCRIPT_ID_FROM ;
INSERT INTO ScriptsTemp
SELECT id_script, filename, type, active,</p>
<blockquote>
<div>directory, id_release,id_order+1 as id_order,
creation_date, update_date</div></blockquote>
<p class="last">FROM Scripts
WHERE $where_moved_record &#8220;</p>
</dd>
</dl>
</div></blockquote>
<p>else</p>
<blockquote>
<div><p>where_moved_record=&#8221;id_order &gt; $id_order_from &#8220;</p>
<dl class="docutils">
<dt>insert2tmp=&#8221;INSERT INTO ScriptsTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_script, filename, type, active,</dt>
<dd>directory, id_release, id_order-1 as id_order,
creation_date, update_date</dd>
</dl>
<p>FROM Scripts
WHERE id_order &gt; $id_order_from AND id_order &lt;= $id_order_to ;
INSERT INTO ScriptsTemp
SELECT id_script, filename, type, active,</p>
<blockquote>
<div>directory, id_release, id_order,
creation_date, update_date</div></blockquote>
<p>FROM Scripts
WHERE id_order &gt; $id_order_to ;
INSERT INTO ScriptsTemp
SELECT id_script, filename, type, active,</p>
<blockquote>
<div>directory, id_release, $id_order_to as id_order,
creation_date, update_date</div></blockquote>
<p class="last">FROM Scripts
WHERE id_script = $DBM_SCRIPT_ID_FROM &#8220;</p>
</dd>
</dl>
</div></blockquote>
<p>fi</p>
<p>t=&#8221;after&#8221;</p>
<p>result=0</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div><p>if [ $id_order_to -lt $id_order_from ] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>where_moved_record=&#8221; id_order &lt; $id_order_from</dt>
<dd>AND id_order &gt;= $id_order_to AND id_release = $DBM_REL_ID &#8220;</dd>
<dt>insert2tmp=&#8221;INSERT INTO ScriptsTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_script, filename, type, active,</dt>
<dd>directory, id_release, id_order+1 as id_order,
creation_date, update_date</dd>
</dl>
<p>FROM Scripts
WHERE $where_moved_record ;
INSERT INTO ScriptsTemp
SELECT id_script, filename, type, active,</p>
<blockquote>
<div>directory, id_release, $id_order_to as id_order,
creation_date, update_date</div></blockquote>
<p class="last">FROM Scripts
WHERE id_script = $DBM_SCRIPT_ID_FROM &#8220;</p>
</dd>
</dl>
</div></blockquote>
<p>else</p>
<blockquote>
<div><dl class="docutils">
<dt>where_moved_record=&#8221;id_order &lt; $id_order_to</dt>
<dd>AND id_order &gt; $id_order_from AND id_release = $DBM_REL_ID &#8220;</dd>
<dt>insert2tmp=&#8221;INSERT INTO ScriptsTemp</dt>
<dd><dl class="first docutils">
<dt>SELECT id_script, filename, type, active,</dt>
<dd>directory, id_release, id_order-1 as id_order,
creation_date, update_date</dd>
</dl>
<p>FROM Scripts
WHERE $where_moved_record ;
INSERT INTO ScriptsTemp
SELECT id_script, filename, type, active,</p>
<blockquote>
<div>directory, id_release, $id_order_to-1 as id_order,
creation_date, update_date</div></blockquote>
<p class="last">FROM Scripts
WHERE id_script = $DBM_SCRIPT_ID_FROM &#8220;</p>
</dd>
</dl>
</div></blockquote>
<p>fi</p>
<p>t=&#8221;before&#8221;
result=0</p>
</div></blockquote>
<p>fi</p>
<p># Create temporary table ddl for script move
_dbm_get_table_schema &#8220;Scripts&#8221;
create_tmp_table=&#8221;$(echo &#8220;$_sqlite_ans&#8221; | sed &#8216;s/TABLE Scripts/TABLE ScriptsTemp/&#8217;)&#8221;</p>
<dl class="docutils">
<dt>delete_scripts=&#8221;DELETE FROM Scripts</dt>
<dd>WHERE ($where_moved_record) OR
(id_release = $DBM_REL_ID AND id_order = $id_order_from ) &#8220;</dd>
</dl>
<p># Disable PRAGMA options
SQLITEDB_INIT_SESSION=&#8221; &#8220;</p>
<dl class="docutils">
<dt>query=&#8221;DROP TABLE IF EXISTS ScriptsTemp ;</dt>
<dd><p class="first">$create_tmp_table
${insert2tmp} ;
${delete_scripts} ;
INSERT INTO Scripts
SELECT id_script, filename, type, active,</p>
<blockquote>
<div>directory, id_release, id_order,
creation_date, DATETIME(&#8216;now&#8217;)</div></blockquote>
<p class="last">FROM ScriptsTemp
WHERE id_release = $DBM_REL_ID ;
DROP TABLE ScriptsTemp &#8220;</p>
</dd>
</dl>
<p>#  SELECT * FROM ScriptsTemp ;
#  SELECT &#8216;-&#8216;  ;
#  SELECT * FROM Scripts ;
_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || error_handled &#8220;Unexpected error on update id_order fields.&#8221;</p>
<p># Re-enable PRAGMA options
unset SQLITEDB_INIT_SESSION</p>
<p>echo -en &#8220;Moved correctly script $DBM_SCRIPT_ID_FROM of the release $DBM_REL_ID ${t} script $DBM_SCRIPT_ID_TO.n&#8221;</p>
<p>return $result</p>
</div></blockquote>
<p>}
# dbm_move_script_end</p>
<p># dbm_dbm_upgrade
dbm_upgrade () {</p>
<blockquote>
<div><p># Shift first two input param
shift 2</p>
<p>_dbm_upgrade &#8220;$&#64;&#8221; || return 1</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm_dbm_upgrade_end</p>
<div class="section" id="internal-functions">
<h1># Internal functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline"></a></h1>
<p># dbm__dbm_init
_dbm_init() {</p>
<blockquote>
<div><p># Load dbm module files
for i in $DBRM_CORE_FILES_DIR/dbm/<a href="#id1"><span class="problematic" id="id2">*</span></a>.inc ; do</p>
<blockquote>
<div>. $i</div></blockquote>
<p>done</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm__dbm_init_end</p>
<p># dbm__dbm_post_init
_dbm_post_init () {</p>
<blockquote>
<div><p># Check if exists DRM_DB
[[ $DEBUG ]] &amp;&amp; echo &#8220;(dbm_post_init: Check if is present sqlite internal db file: $DRM_DB)&#8221;
if [[ ! -e $DRM_DB ]] ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>if [[ -z &#8220;$DRM_PROFILE&#8221; || $DRM_PROFILE -eq 0 ]] ; then</dt>
<dd><p class="first">[[ $DEBUG ]] &amp;&amp; echo &#8220;(dbm_post_init: Create sqlite internal db file: $DRM_DB)&#8221;
_sqlite_create -c &#8220;$DRM_DB&#8221; -s &#8220;$dbm_schema&#8221; || error_handled &#8220;Error on create $DRM_DB file.&#8221;</p>
<p class="last">_dbm_exts_check_extensions &#8220;0&#8221; || error_handled &#8220;Error on initialize extensions.&#8221;</p>
</dd>
</dl>
<p>fi</p>
</div></blockquote>
<p>else</p>
<blockquote>
<div><dl class="docutils">
<dt>if [[ x&#8221;$2&#8221; != x&#8221;upgrade&#8221; &amp;&amp; x&#8221;$2&#8221; != x&#8221;shell&#8221; &amp;&amp; x&#8221;$2&#8221; != x&#8221;info&#8221; ]] ; then</dt>
<dd><p class="first"># Check if it is needed an upgrade
_dbm_exts_check_dbm || error_handled </p>
<blockquote class="last">
<div>&#8220;Execute &#8216;dbrm dbm upgrade&#8217; to upgrade internal database.&#8221;</div></blockquote>
</dd>
</dl>
<p>fi</p>
</div></blockquote>
<p>fi</p>
<p># Check if is defined undo script path
if [[ -z &#8220;$DBM_UNDO_SCRIPT&#8221; ]] ; then</p>
<blockquote>
<div># Use default path
DBM_UNDO_SCRIPT=$LOCAL_DIR/dbm_undo.sh</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd><dl class="first docutils">
<dt>if [[ ! -e $DBM_UNDO_SCRIPT ]] ; then</dt>
<dd>error_generate &#8220;Invalid DBM Undo script path defined.&#8221;</dd>
</dl>
<p class="last">fi</p>
</dd>
</dl>
<p>fi</p>
<p># Check if is defined history script path
if [[ -z &#8220;$DBM_HISTORY&#8221; ]] ; then</p>
<blockquote>
<div># Use default path
DBM_HISTORY=$LOCAL_DIR/.dbm_history</div></blockquote>
<dl class="docutils">
<dt>else</dt>
<dd><dl class="first docutils">
<dt>if [[ ! -e $DBM_HISTORY ]] ; then</dt>
<dd>error_generate &#8220;Invalid DBM history file path defined.&#8221;</dd>
</dl>
<p class="last">fi</p>
</dd>
</dl>
<p>fi</p>
<p>[[ $DEBUG ]] &amp;&amp; echo &#8220;(dbm_post_init: Use undo script: $DBM_UNDO_SCRIPT.)&#8221;</p>
<p>export DBM_UNDO_SCRIPT DBM_HISTORY</p>
</div></blockquote>
<p>}
# dbm__dbm_post_init_end</p>
<p># dbm__dbm_upgrade
_dbm_upgrade () {</p>
<blockquote>
<div><p>local i=0
local tschema=&#8221;&#8220;</p>
<p># Check if all tables are present
for i in $dbm_tables ; do</p>
<blockquote>
<div><p>if _sqlite_exists_table -c &#8220;$DRM_DB&#8221; -t &#8220;$i&#8221; ; then</p>
<blockquote>
<div><dl class="docutils">
<dt>_sqlite_get_tschema_from_file &#8220;$dbm_schema&#8221; &#8220;$i&#8221; || </dt>
<dd>error_generate &#8220;Error on retrieve schema of the table $i.&#8221;</dd>
</dl>
<p>query=&#8221;$_sqlite_ans&#8221;</p>
<dl class="docutils">
<dt>_sqlite_query -c &#8220;$DRM_DB&#8221; -q &#8220;$query&#8221; || </dt>
<dd>error_handled &#8220;Error on create table $i.&#8221;</dd>
</dl>
<p>out_handler_print &#8220;Created table $i correctly.&#8221;</p>
</div></blockquote>
<p>fi</p>
</div></blockquote>
<p>done</p>
<p># Check if all modules are present on Extensions table.
_dbm_exts_check_extensions || error_generate &#8220;Error on verify extentensions.&#8221;</p>
<p># Check if it is needed execute upgrade scripts for dbm module.</p>
<p>return 0</p>
</div></blockquote>
<p>}
# dbm__dbm_upgrade_end</p>
<p># vim: syn=sh filetype=sh ts=2 sw=2</p>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
      
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>