#!/bin/bash
#------------------------------------------------
# Author(s): Geaaru, geaaru@gmail.com
# $Id$
# License: GPL 2.0
#------------------------------------------------

name="mongo"
mongo_authors="Geaaru"
mongo_creation_date="June 24, 2016"
mongo_version="@PACKAGE_VERSION@"
mongo_status="0"


# mongo_mongo_version
mongo_version() {
  echo -en "Version: ${mongo_version}\n"
  return 0
}
# mongo_mongo_version_end

# mongo_mongo_long_help
mongo_long_help () {

   echo -en "===========================================================================\n"
   echo -en "Module [mongo]:\n"
   echo -en "Author(s): ${mongo_authors}\n"
   echo -en "Created: ${mongo_creation_date}\n"
   echo -en "Version: ${mongo_version}\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "\tlong_help               Show long help informations\n"
   echo -en "\tshow_help               Show command list.\n"
   echo -en "\tversion                 Show module version.\n"
   echo -en "\ttest_connection         Test connection versus database.\n"
   echo -en "\tshell                   Enter on command line shell of database.\n"
   echo -en "\tcompile                 Compile files/indexes/scripts.\n"
   echo -en "\tshow                    Show collections, indexes, etc.\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "===========================================================================\n"

   return 0
}
# mongo_mongo_long_help_end

# mongo_mongo_show_help
mongo_show_help () {
   echo -en "===========================================================================\n"
   echo -en "Module [mongo]:\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "\tlong_help               Show long help informations\n"
   echo -en "\tshow_help               Show command list.\n"
   echo -en "\tversion                 Show module version.\n"
   echo -en "\ttest_connection         Test connection versus database.\n"
   echo -en "\tshell                   Enter on command line shell of database.\n"
   echo -en "\tcompile                 Compile files/indexes/scripts.\n"
   echo -en "\tshow                    Show collections, indexes, etc.\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "===========================================================================\n"

   return 0
}
# mongo_mongo_show_help_end

# mongo_mongo_shell
mongo_shell () {

  local result=1

  # Shift first two input param
  shift 2

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  commons_mongo_shell || error_handled "Error on enter on command line shell."

  return 0
}
# mongo_mongo_shell_end

# mongo_mongo_test_connection
mongo_test_connection () {

  local result=1

  # Shift first two input param
  shift 2

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  out_handler_print "Connected to $MONGO_DB with user $MONGO_USER correctly."

  out_handler_clean

  return 0
}
# mongo_mongo_test_connection_end

# mongo_mongo_compile
mongo_compile () {

  # Shift first two input param
  shift 2

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  _mongo_compile_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  _mongo_compile || error_handled ""

  out_handler_print "Compile operation successfull."

  return 0
}
# mongo_mongo_compile_end

# mongo_mongo_show
mongo_show () {

  # Shift first two input param
  shift 2

  _mongo_show_help () {

    echo -en "[--indexes]              Show list of indexes present on database.\n"
    echo -en "[--collections]          Show list of collections present on database.\n"
    echo -en "[--all]                  Show list of all indexes, collections on database.\n"
    echo -en "[--collection CNAME]     Show detail of a collection. This option could be repeated.\n"
    echo -en "[--index INAME]          Show detail of a index. This option could be repeated.\n"
    echo -en "                         INAME contains name of the collection for retrieve all\n"
    echo -en "                         indexes of a specific collection or name of the collection \n"
    echo -en "                         with key name separated with a point.\n"
    echo -en "\n"

    return 0
  }

  _mongo_show_args () {

    [[ $DEBUG && $DEBUG == true ]] && \
      echo -en "(_mongo_show_args args: $@)\n"

    local short_options="U:P:hH:D:t:S:"
    local long_options="database: authdb: conn-options: help" # connection long options
    long_options="$long_options all indexes collections index: collection:"

    set -- `getopt -u -q -a -o "$short_options" -l "$long_options" -- "$@"` || \
      error_handled "Invalid parameters"

    if [ $# -lt 2 ] ; then # is there at least one param (--)
      _mongo_show_help
      return 1
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_show_args: Found $# params)\n"

    MONGO_SHOW_ALL=0
    MONGO_SHOW_ALL_COLLECTIONS=0
    MONGO_SHOW_ALL_INDEXES=0
    MONGO_SHOW_COLL_DESCR=0
    MONGO_SHOW_INDEX_DESCR=0
    MONGO_SHOW_COLLS=""
    MONGO_SHOW_INDEXES=""

    while [ $# -gt 0 ] ; do
      case "$1" in

        -U|-P|-D|-H|--database|--authdb|--conn-options)
          shift
          # do nothing
          ;;

        --indexes)
          MONGO_SHOW_ALL_INDEXES=1
          ;;
        --collections)
          MONGO_SHOW_ALL_COLLECTIONS=1
          ;;
        --all)
          MONGO_SHOW_ALL=1
          ;;
        --index)
          MONGO_SHOW_INDEX[$MONGO_SHOW_INDEX_DESCR]="$2"
          let MONGO_SHOW_INDEX_DESCR++
          shift
          ;;
        --collection)
          MONGO_SHOW_COLLS[$MONGO_SHOW_COLL_DESCR]="$2"
          let MONGO_SHOW_COLL_DESCR++
          shift
          ;;
        -h|--help)
          _mongo_show_help
          return 1
          ;;
        --)
          ;;
        *)
          error_generate "Invalid parameter $1."
          ;;

      esac

      shift
    done

    return 0
  }

  _mongo_check_status

  _mongo_connections_args "$@" || error_handled ""

  _mongo_show_args "$@" || error_handled ""

  unset -f _mongo_show_args
  unset -f _mongo_show_help

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "Mongo client was unable to connecto to DB with supplied credentials."

  _mongo_show || error_handled "Error"

  return 0
}

##################################################################
# Internal functions
##################################################################

# mongo__mongo_init
#   Internal function called on initialization of the mongo module.
#
#   Mongo module is usable when SQLCA variable contains mongo string.
#   So, if mongo module is enabled then these check are done:
#   * verify presence of mysql client program
#   * check if MONGO_USER variable is set. This variable define user to use
#     on connection to database.
#   * check if MONGO_PWD variable is set. This variable define password to use
#     on connection to database.
#   * check if defined MONGO_DB variable. This variable define name of the
#     schema to use on connection.
#   * check if defined MONGO_DIR variable. This variable define path where
#     save/retrieve files to compile.
_mongo_init () {

  if [[ ! -z "$SQLCA"  && "$SQLCA" =~ .*mongo.* ]] ; then

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_init: Check requirements of the mongo module.)\n"

    commons_mongo_check_client || error_handled ""

    if [ -z $MONGO_TMZ ] ; then
      MONGO_TMZ='UTC'
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_init: All requirements are present. Continue my work.)\n"

    mongo_status="1"

  else

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_init: Nothing to do.)\n"

  fi

  return 0
}
# mongo__mongo_init_end

# mongo__mongo_check_status
#
#   Check status of the mongo module.
# RETURN VALUE
#   0 if module is enable.
#   exit if not enabled.
_mongo_check_status () {

  if [ x"$mongo_status" = x"0" ] ; then
    error_generate "mongo is not enable. Enable it with SQLCA variable"
  fi

  return 0
}
# mongo__mongo_check_status_end

#****f* mongo/_mongo_connections_args
# FUNCTION
#   Parse command line and define environment variables.
# DESCRIPTION
#   Available commands line are:
#   * -U [user]           Override username variable used on connection. If not present it is used
#                         MONGO_USER variable from configuration file.
#   * -P [pwd]            Override password variable used on connection. If not present it is used
#                         MONGO_PWD variable from configuration file.
#   * -D [dir path]       To define path where save/retrieve files to download/compile. This option
#                         override MONGO_DIR variable of configuration file.
#   * -H                  Override database host. If not present it is used MONGO_HOST variable
#                         from configuration file.
#   * --database [db]     Override database name variable used on connection. If not present it is used
#                         MONGO_DB variable from configuration file.
#   * --authdb [db]       Override authentication database variable used on connection initialization.
#                         If not present it is used MONGO_AUTHDB variable from configuration file.
#   * --conn-options [option]
#                         Permit to configure extra connection parameters. This option could be used
#                         more of one time.
#   * -h                  Show help message
# SOURCE
_mongo_connections_args () {

  [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_connections_args args: $@)\n"

  local short_options="U:P:hH:D:t:S:"
  local long_options="database: authdb: conn-options:  help"

  $(set -- $(getopt -u -q -o "$short_options" -l "$long_options" -- "$@")) || \
    error_handled "Invalid parameters"

  [ $# -lt 1 ] && return 0 # is there at least one param (--)

  local MONGO_EXTRAS_ENABLE=0

  while [ $# -gt 0 ] ; do
    case "$1" in

      -U) MONGO_USER="$2";shift;;
      -P) MONGO_PWD="$2";shift;;
      -D) MONGO_DIR="$2";shift;;
      -H) MONGO_HOST="$2";shift;;
      --database)
        MONGO_DB="$2"
        shift
        ;;
      --authdb)
        MONGO_AUTHDB="$2"
        shift
        ;;
      --conn-options)
        if [ $MONGO_EXTRAS_ENABLE -eq 0 ] ; then
          MONGO_EXTRAS_ENABLE=1
          MONGO_EXTRA_OPTIONS="$2"
        else
          MONGO_EXTRA_OPTIONS="$MONGO_EXTRA_OPTIONS $2"
        fi
        shift
        ;;
      --help|-h)
        if [ -n "$_mongo_help_message" ] ; then
          _mongo_connection_help
          return 0
        fi
        return 1
        ;;
      *|--)
        ;;

    esac

    shift

  done

  return 0
}
#***


#****f* mongo/_mongo_connection_help
# FUNCTION
#   Internal function that print help message of connection options.
# SOURCE
_mongo_connection_help () {

  echo "
[-P mongo_pwd]            Override MONGO_PWD variable.
[-U mongo_user]           Override MONGO_USER with username of the connection.
[-H mongo_host]           Override MONGO_HOST with host of the database.
[-D mongo_dir]            Override MONGO_DIR directory where save/retrieve script/functions, etc.
[--database db]           Override MONGO_DB variable for database name.
[--conn-options opts]     Override MONGO_EXTRA_OPTIONS variable for enable extra connection options.
[--authdb db]             Override MONGO_AUTHDB variable for set authentication database.
"

  return 0
}
#***

# mongo__mongo_compile_args
_mongo_compile_args () {

  [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_compile_args args: $@)\n"

  local short_options="U:P:hH:D:t:S:"
  local long_options="database: authdb: conn-options:  help"

  # mongo__mongo_compile_help
  _mongo_compile_help () {
    echo -en "[--file file]            Compile a particular file. (Use ABS Path or relative path from current dir.)\n"

    return 0
  }
  # mongo__mongo_compile_help_end

  long_options="$long_options file:"

  $(set -- $(getopt -u -q -o "$short_options" -l "$long_options" -- "$@")) || \
    error_handled "Invalid parameters"

  if [ $# -lt 2 ] ; then
    _mongo_compile_help
    return 1
  fi

  MONGO_COMPILE_FILE=""

  while [ $# -gt 0 ] ; do
    case "$1" in

      -U|-P|-D|-H|--database|--authdb)
        # do nothing
        shift
        ;;
      --conn-options)
        # do nothing
        shift
        ;;
      --file)
        MONGO_COMPILE_FILE="$2"
        shift
        ;;
      --help|-h)
        if [ -n "$_mongo_help_message" ] ; then
          _mongo_connection_help
          return 0
        fi
        return 1
        ;;
      *|--)
        ;;

    esac

    shift
  done

  unset -f _mongo_compile_help

  return 0
}
# mongo__mongo_compile_args_end

# mongo__mongo_compile
_mongo_compile () {

  local f=""

  [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_compile args: $@)\n"

  # Compile single file
  if [ -n "${MONGO_COMPILE_FILE}" ] ; then

    # TODO: Check when use MONGO_INITRC
    commons_mongo_compile_file "$MONGO_COMPILE_FILE" "File $MONGO_COMPILE_FILE" "1" || \
      error_handled "Error on compile file $MONGO_COMPILE_FILE."

  fi

  return 0
}
# mongo__mongo_compile_end

# mongo__mongo_show
_mongo_show () {

  if [ $MONGO_SHOW_ALL -eq 1 ] ; then

    _mongo_show_indexes

    _mongo_show_collections

  fi

  if [ $MONGO_SHOW_ALL_INDEXES -eq 1 ] ; then

    _mongo_show_indexes

  fi

  if [ $MONGO_SHOW_ALL_COLLECTIONS -eq 1 ] ; then

    _mongo_show_collections

  fi

  # Show single collection data
  if [ $MONGO_SHOW_COLL_DESCR -gt 0 ] ; then

    for i in ${!MONGO_SHOW_COLLS[@]}
    do

      _mongo_show_collections ${MONGO_SHOW_COLLS[$i]}

      out_handler_print "\n"

    done

  fi

  # Show single index data
  if [ $MONGO_SHOW_INDEX_DESCR -gt 0 ] ; then

    local coll=""
    local key=""
    local show_detail=1
    for i in ${!MONGO_SHOW_INDEX[@]}
    do

      coll=""
      key=""
      show_detail=1

      coll=$(echo ${MONGO_SHOW_INDEX[$i]} | cut -d'.' -f 1)
      key=$(echo ${MONGO_SHOW_INDEX[$i]} | cut -d'.' -f 2)

      if [ $coll = $key ] ; then
        # POST: not . on string.
        key=""
        show_detail=0
      fi

      _mongo_show_indexes "${coll}" "${key}" ${show_detail}

      out_handler_print "\n"

    done

  fi

  return 0
}
# mongo__mongo_show_end

# mongo__mongo_show_collections
_mongo_show_collections () {

  local collection="$1"
  local i=0
  local coll_name=25
  local stosize_name=20
  local counter=0
  local count_name=20

  commons_mongo_stats "${collection}" "collection" || \
    error_handled "Error on retrieve collections list."

  local n_colls=${#mongo_stats[@]}

  if [ $n_colls -eq 0 ] ; then

    out_handler_print "No collections available."

  else

    # Number of indexes must be divided by 11
    # number of entries data for collection
    # because I use an associative array.
    n_colls=$((n_colls/11))

    if [[ -n "${collection}" ]] ; then

      # POST: show detail of single collection
      #       with a vertical table.
      out_ttitle="Detail of collection ${collection}"

      out_headers[0]="COLLECTION"
      out_headers[1]="SHARDED"
      out_headers[2]="CAPPED"
      out_headers[3]="N. INDEX"
      out_headers[4]="STORAGE SIZE (KB)"
      out_headers[5]="PRIMARY"
      out_headers[6]="N. DOCS"
      out_headers[7]="TOTAL INDEX SIZE (KB)"
      out_headers[8]="AVERAGE OBJ SIZE (KB)"
      out_headers[9]="SIZE (KB)"
      out_headers[10]="SHARDED NODES"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"
      out_el_pre[5]="\e[1;30m"
      out_el_pre[6]="\e[1;29m"
      out_el_pre[7]="\e[1;36m"
      out_el_pre[8]="\e[1;37m"
      out_el_pre[9]="\e[1;34m"
      out_el_pre[10]="\e[1;33m"

      out_el_post[0]="\e[m"

      out_htabs_mode="htabs"
      out_prepost_mode="any"
      out_vertical=1
      out_vert_sep="=============================================================================================================================="

      local coll=${mongo_stats[$i, 0]}
      local storsize=${mongo_stats[$i, 1]}
      local sharded=${mongo_stats[$i, 2]}
      local primary=${mongo_stats[$i, 3]}
      local count=${mongo_stats[$i, 4]}
      local n_idx=${mongo_stats[$i, 5]}
      local totIdx=${mongo_stats[$i, 6]}
      local capped=${mongo_stats[$i, 7]}
      local avgObjSize=${mongo_stats[$i, 8]}
      local size=${mongo_stats[$i, 9]}
      local shardedNodes=${mongo_stats[$i, 10]}

      eval "unset row${counter}"
      out_rows[$counter]="row${counter}"

      eval "row${counter}[0]=\"${coll}\""
      eval "row${counter}[1]=\"${sharded}\""
      eval "row${counter}[2]=\"${capped}\""
      eval "row${counter}[3]=\"${n_idx}\""
      eval "row${counter}[4]=\"${storsize}\""
      eval "row${counter}[5]=\"${primary}\""
      eval "row${counter}[6]=\"${count}\""
      eval "row${counter}[7]=\"${totIdx}\""
      eval "row${counter}[8]=\"${avgObjSize}\""
      eval "row${counter}[9]=\"${size}\""
      eval "row${counter}[10]=\"${shardedNodes}\""

      out_tabs[0]="30"
      out_htabs[0]="30"

      out_handler_print_arr

    else # else of if -n detail

      out_hsep=1
      out_prepost_mode="any"
      out_htabs_mode="tabs"

      if [ -n "${collection}" ] ; then
        out_ttitle="Collection ${collection}"
      else
        out_ttitle="Collections"
      fi

      out_headers[0]="COLLECTION"
      out_headers[1]="SHARDED"
      out_headers[2]="N. INDEX"
      out_headers[3]="STORAGE SIZE (KB)"
      out_headers[4]="PRIMARY"
      out_headers[5]="N. DOCS"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"
      out_el_pre[5]="\e[1;29m"

      out_el_post[0]="\e[m"

      for ((i=0; i<${n_colls}; i++)) ; do

        local coll=${mongo_stats[$i, 0]}
        local storsize=${mongo_stats[$i, 1]}
        local sharded=${mongo_stats[$i, 2]}
        local primary=${mongo_stats[$i, 3]}
        local count=${mongo_stats[$i, 4]}
        local n_idx=${mongo_stats[$i, 5]}

        # Clean previous row array
        eval "unset row${counter}"
        out_rows[$counter]="row"${counter}

        eval "row${counter}[0]=\"${coll}\""
        eval "row${counter}[1]=\"${sharded}\""
        eval "row${counter}[2]=\"${n_idx}\""
        eval "row${counter}[3]=\"${storsize}\""
        eval "row${counter}[4]=\"${primary}\""
        eval "row${counter}[5]=\"${count}\""

        # Check if needed enlarge size of first column
        if [ ${#coll} -ge $coll_name ] ; then
          coll_name=$((${#coll}+1))
        fi
        if [ ${#storsize} -ge $stosize_name ] ; then
          stosize_name=$((${#stosize}+1))
        fi
        if [ ${#count} -ge $count_name ] ; then
          count_name=$((${#count}+1))
        fi

        let counter++

      done

      out_tabs[0]="$coll_name"
      out_tabs[1]="9"
      out_tabs[2]="9"
      out_tabs[3]="$stosize_name"
      out_tabs[4]="10"
      out_tabs[5]="$count_name"

      out_handler_print_arr
      out_handler_print "\nFound ${n_colls} collections."

    fi # end if detail

  fi

  out_handler_clean

  return 0
}
# mongo__mongo_show_collections_end

# mongo__mongo_show_indexes
_mongo_show_indexes () {

  local collection="$1"
  local keyname="$2"
  local detail="$3"
  local i=0
  local coll_name=25
  local key_name=25
  local keys_name=30

  commons_mongo_get_indexes_list "${collection}" "${keyname}" || \
    error_handled "Error on retrieve indexes list."

  local n_indexes=${#mongo_indexes[@]}

  if [ $n_indexes -eq 0 ] ; then

    out_handler_print "No indexes available."

  else

    # Number of indexes must be divided by 6.
    # number of entries data for index
    # because I use an associative array.
    n_indexes=$((n_indexes/6))

    if [[ -n ${detail} ]] ; then

      # POST: show detail of single collection
      #       with a vertical table.
      out_ttitle="Index detail for collection ${collection}"
      [[ -n "${keyname}" ]] && out_ttitle="${out_ttitle} and key ${keyname}"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"
      out_el_post[0]="\e[m"

      out_headers[0]="COLLECTION"
      out_headers[1]="KEY NAME"
      out_headers[2]="NUM. KEYS"
      out_headers[3]="KEYS"
      out_headers[4]="INDEX SIZE (KB)"

      out_htabs_mode="htabs"
      out_prepost_mode="any"
      out_vertical=1
      out_vert_sep="=============================================================================================================================="

      local counter=0

      for ((i=0; i<${n_indexes}; i++)) ; do

        local kcoll=${mongo_indexes[$i, 0]}
        local kname=${mongo_indexes[$i, 1]}
        local n_keys=${mongo_indexes[$i, 3]}
        local keys=${mongo_indexes[$i, 4]}
        local idxsize=${mongo_indexes[$i, 5]}

        # Clean previous row array
        eval "unset row${counter}"
        out_rows[$counter]="row"${counter}

        eval "row${counter}[0]=\"${kcoll}\""
        eval "row${counter}[1]=\"${kname}\""
        eval "row${counter}[2]=\"${n_keys}\""
        eval "row${counter}[3]=\"${keys}\""
        eval "row${counter}[4]=\"${idxsize}\""

        let counter++

      done

      out_tabs[0]="30"
      out_htabs[0]="30"

      out_handler_print_arr

    else # else of if -n detail

      out_hsep=1
      out_prepost_mode="any"
      out_htabs_mode="tabs"

      if [ -n "${collection}" ] ; then
        out_ttitle="Index detail for collection ${collection}"
      else
        out_ttitle="Indexes"
      fi
      out_headers[0]="COLLECTION"
      out_headers[1]="KEY NAME"
      out_headers[2]="# KEYS"
      out_headers[3]="KEYS"
      out_headers[4]="INDEX SIZE (KB)"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"

      out_el_post[0]="\e[m"

      local counter=0

      for ((i=0; i<${n_indexes}; i++)) ; do

        local kcoll=${mongo_indexes[$i, 0]}
        local kname=${mongo_indexes[$i, 1]}
        local keys=${mongo_indexes[$i, 2]}
        local n_keys=${mongo_indexes[$i, 3]}
        local idxsize=${mongo_indexes[$i, 5]}

        # Clean previous row array
        eval "unset row${counter}"
        out_rows[$counter]="row"${counter}

        eval "row${counter}[0]=\"${kcoll}\""
        eval "row${counter}[1]=\"${kname}\""
        eval "row${counter}[2]=\"${n_keys}\""
        eval "row${counter}[3]=\"${keys}\""
        eval "row${counter}[4]=\"${idxsize}\""

        # Check if needed enlarge size of first column
        if [ ${#kcoll} -ge $coll_name ] ; then
          coll_name=$((${#kcoll}+1))
        fi
        if [ ${#kname} -ge $key_name ] ; then
          key_name=$((${#kname}+1))
        fi

        if [ ${#keys} -ge $keys_name ] ; then
          keys_name=$((${#keys}+1))
        fi

        let counter++

      done

      out_tabs[0]="$coll_name"
      out_tabs[1]="$key_name"
      out_tabs[2]="8"
      out_tabs[3]="$keys_name"
      out_tabs[4]="20"

      out_handler_print_arr
      out_handler_print "\nFound ${n_indexes} indexes."

    fi

    out_stdout_clean

  fi

  return 0
}
# mongo__mongo_show_indexes_end


# vim: syn=sh filetype=sh
