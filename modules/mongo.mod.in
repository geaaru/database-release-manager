#!/bin/bash
#------------------------------------------------
# Author(s): Geaaru, geaaru@gmail.com
# $Id$
# License: GPL 2.0
#------------------------------------------------

name="mongo"
mongo_authors="Geaaru"
mongo_creation_date="June 24, 2016"
mongo_version="@PACKAGE_VERSION@"
mongo_status="0"


# mongo_mongo_version
mongo_version() {
  echo -en "Version: ${mongo_version}\n"
  return 0
}
# mongo_mongo_version_end

# mongo_mongo_long_help
mongo_long_help () {

   echo -en "===========================================================================\n"
   echo -en "Module [mongo]:\n"
   echo -en "Author(s): ${mongo_authors}\n"
   echo -en "Created: ${mongo_creation_date}\n"
   echo -en "Version: ${mongo_version}\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "\tlong_help               Show long help informations\n"
   echo -en "\tshow_help               Show command list.\n"
   echo -en "\tversion                 Show module version.\n"
   echo -en "\ttest_connection         Test connection versus database.\n"
   echo -en "\tshell                   Enter on command line shell of database.\n"
   echo -en "\tcompile                 Compile files/indexes/scripts.\n"
   echo -en "\tshow                    Show collections, indexes, etc.\n"
   echo -en "\tdownload                Download indexes/scripts.\n"
   echo -en "\tcreate                  Create indexes.\n"
   echo -en "\tdrop                    Drop indexes.\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "===========================================================================\n"

   return 0
}
# mongo_mongo_long_help_end

# mongo_mongo_show_help
mongo_show_help () {
   echo -en "===========================================================================\n"
   echo -en "Module [mongo]:\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "\tlong_help               Show long help informations\n"
   echo -en "\tshow_help               Show command list.\n"
   echo -en "\tversion                 Show module version.\n"
   echo -en "\ttest_connection         Test connection versus database.\n"
   echo -en "\tshell                   Enter on command line shell of database.\n"
   echo -en "\tcompile                 Compile files/indexes/scripts.\n"
   echo -en "\tshow                    Show collections, indexes, etc.\n"
   echo -en "\tdownload                Download indexes/scripts.\n"
   echo -en "\tcreate                  Create indexes.\n"
   echo -en "\tdrop                    Drop indexes.\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "===========================================================================\n"

   return 0
}
# mongo_mongo_show_help_end

# mongo_mongo_shell
mongo_shell () {

  local result=1

  # Shift first two input param
  shift 2

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  commons_mongo_shell || error_handled "Error on enter on command line shell."

  return 0
}
# mongo_mongo_shell_end

# mongo_mongo_test_connection
mongo_test_connection () {

  local result=1

  # Shift first two input param
  shift 2

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  out_handler_print "Connected to $MONGO_DB with user $MONGO_USER correctly."

  out_handler_clean

  return 0
}
# mongo_mongo_test_connection_end

# mongo_mongo_compile
mongo_compile () {

  # Shift first two input param
  shift 2

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  _mongo_compile_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  _mongo_compile || error_handled ""

  out_handler_print "Compile operation successfull."

  return 0
}
# mongo_mongo_compile_end

# mongo_mongo_show
mongo_show () {

  # Shift first two input param
  shift 2

  _mongo_show_help () {

    echo -en "[--indexes]              Show list of indexes present on database.\n"
    echo -en "[--collections]          Show list of collections present on database.\n"
    echo -en "[--all]                  Show list of all indexes, collections on database.\n"
    echo -en "[--collection CNAME]     Show detail of a collection. This option could be repeated.\n"
    echo -en "[--index INAME]          Show detail of a index. This option could be repeated.\n"
    echo -en "                         INAME contains name of the collection for retrieve all\n"
    echo -en "                         indexes of a specific collection or name of the collection \n"
    echo -en "                         with key name separated with a point.\n"
    echo -en "[--exclude-id]           Exclude special index _id.\n"
    echo -en "\n"

    return 0
  }

  _mongo_show_args () {

    [[ $DEBUG && $DEBUG == true ]] && \
      echo -en "(_mongo_show_args args: $@)\n"

    local short_options="U:P:hH:D:t:S:"
    local long_options="database: authdb: conn-options: help" # connection long options
    long_options="$long_options all indexes collections index: collection: exclude-id"

    set -- `getopt -u -q -a -o "$short_options" -l "$long_options" -- "$@"` || \
      error_handled "Invalid parameters"

    if [ $# -lt 2 ] ; then # is there at least one param (--)
      _mongo_show_help
      return 1
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_show_args: Found $# params)\n"

    MONGO_SHOW_ALL=0
    MONGO_SHOW_ALL_COLLECTIONS=0
    MONGO_SHOW_ALL_INDEXES=0
    MONGO_SHOW_COLL_DESCR=0
    MONGO_SHOW_INDEX_DESCR=0
    MONGO_SHOW_COLLS=""
    MONGO_SHOW_INDEXES=""
    MONGO_SHOW_EXCLUDEID=0

    while [ $# -gt 0 ] ; do
      case "$1" in

        -U|-P|-D|-H|--database|--authdb|--conn-options)
          shift
          # do nothing
          ;;

        --indexes)
          MONGO_SHOW_ALL_INDEXES=1
          ;;
        --collections)
          MONGO_SHOW_ALL_COLLECTIONS=1
          ;;
        --all)
          MONGO_SHOW_ALL=1
          ;;
        --exclude-id)
          MONGO_SHOW_EXCLUDEID=1
          ;;
        --index)
          MONGO_SHOW_INDEX[$MONGO_SHOW_INDEX_DESCR]="$2"
          let MONGO_SHOW_INDEX_DESCR++
          shift
          ;;
        --collection)
          MONGO_SHOW_COLLS[$MONGO_SHOW_COLL_DESCR]="$2"
          let MONGO_SHOW_COLL_DESCR++
          shift
          ;;
        -h|--help)
          _mongo_show_help
          return 1
          ;;
        --)
          ;;
        *)
          error_generate "Invalid parameter $1."
          ;;

      esac

      shift
    done

    return 0
  }

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  _mongo_show_args "$@" || error_handled ""

  unset -f _mongo_show_args
  unset -f _mongo_show_help

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "Mongo client was unable to connecto to DB with supplied credentials."

  _mongo_show || error_handled "Error"

  return 0
}
# mongo_mongo_show_end

# mongo_mongo_download
mongo_download () {

  # Shift first two input param
  shift 2

  _mongo_download_help () {

    echo -en "[--indexes]              Download all indexes present on database.\n"
    echo -en "[--include-id]           Download also special index _id that aren't\n"
    echo -en "                         available only for capped collection created with\n"
    echo -en "                         autoIndexId option to false using db.createCollection.\n"
    echo -en "                         On default _id index aren't downloaded.\n"
    echo -en "[--index INAME]          Index name to download.\n"
    echo -en "                         It is possible download only a single index a time.\n"
    echo -en "                         INAME contains name of the collection for download all\n"
    echo -en "                         indexes of a specific collection or name of the collection \n"
    echo -en "                         with key name separated with a point.\n"

    echo -en "\n"

    return 0
  }

  _mongo_download_args () {

    [[ $DEBUG && $DEBUG == true ]] && \
      echo -en "(_mongo_download_args args: $@)\n"

    local short_options="U:P:hH:D:t:S:"
    local long_options="database: authdb: conn-options: help" # connection long options
    long_options="$long_options indexes index: include-id"

    set -- `getopt -u -q -a -o "$short_options" -l "$long_options" -- "$@"` || \
      error_handled "Invalid parameters"

    if [ $# -lt 2 ] ; then # is there at least one param (--)
      _mongo_download_help
      return 1
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_download_args: Found $# params)\n"

    MONGO_DOWNLOAD_ALL_INDEXES=0
    MONGO_DOWNLOAD_INDEX=""
    MONGO_DOWNLOAD_INC_ID=0

    while [ $# -gt 0 ] ; do
      case "$1" in

        -U|-P|-D|-H|--database|--authdb|--conn-options)
          shift
          # do nothing
          ;;

        --indexes)
          MONGO_DOWNLOAD_ALL_INDEXES=1
          ;;
        --include-id)
          MONGO_DOWNLOAD_INC_ID=1
          ;;
        --index)
          [ -n $MONGO_DOWNLOAD_INDEX ] && \
            error_handled "Error: --index option used multiple times"
          [ -z "$2" ] && \
            error_handled "Error: invalid value for param --index"

          MONGO_DOWNLOAD_INDEX=$2
          shift
          ;;
        -h|--help)
          _mongo_download_help
          return 1
          ;;
        --)
          ;;
        *)
          error_generate "Invalid parameter $1."
          ;;

      esac

      shift
    done

    return 0
  }

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  _mongo_download_args "$@" || error_handled ""

  unset -f _mongo_download_args
  unset -f _mongo_download_help

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  if [ $MONGO_DOWNLOAD_ALL_INDEXES -eq 1 ] ; then

    commons_mongo_download_all_indexes "" ${MONGO_DOWNLOAD_INC_ID} || error_handled ""

  else

    local coll=""
    local key=""

    coll=$(echo ${MONGO_DOWNLOAD_INDEX} | cut -d'.' -f 1)
    key=$(echo ${MONGO_DOWNLOAD_INDEX} | cut -d'.' -f 2)

    if [ $coll = $key ] ; then
      # POST: not . on string.
      key=""
    fi

    if [ -z "${key}" ] ; then
      commons_mongo_download_all_indexes "${coll}" ${MONGO_DOWNLOAD_INC_ID} || error_handled ""
    else
      commons_mongo_download_index "${coll}" "${key}" || error_handled ""

      out_handler_print "Downloaded index ${key} of collection ${coll} (1 of 1).\n"
    fi

  fi

  return 0
}
# mongo_mongo_download_end

# mongo_mongo_create
mongo_create () {

  # Shift first two input param
  shift 2

  _mongo_create_help () {

    echo -en "[--indexes]              Download all indexes present on database.\n"
    echo -en "[--index INAME]          Index name to download.\n"
    echo -en "                         It is possible download only a single index a time.\n"
    echo -en "                         INAME contains name of the collection for download all\n"
    echo -en "                         indexes of a specific collection or name of the collection \n"
    echo -en "                         with key name separated with a point.\n"
    echo -en "[--unique]               To use with --index option for create an unique index.\n"
    echo -en "[--expire-sec SEC]       To use with --index option for set expireAfterSeconds option.\n"
    echo -ne "                         SEC contains number of seconds.\n"
    echo -ne "[--opt JSON_CONTENT]     Add custom index option as JSON content (without braces).\n"
    echo -ne "                         To use with --index option and could be use multiple time.\n"
    echo -en "[--key KEY_JSON_CONT]    Indicate key fields to use. This option could be used multiple.\n"
    echo -ne "                         time or it is possible define multiple keys on single option.\n"
    echo -ne "[--background]           Enable creation of index in background. Default is false.\n"
    echo -en "\n"
    echo -en "Example1 - Create an unique index for collection test1 on reverse order:\n"
    echo -en "\$> dbrm mongo create --index test1.field1 --unique --key \"field1:-1\"\n"
    echo -en "\n"
    echo -en "Example2 - Create an expire index for collection test1 of two fields:\n"
    echo -en "\$> dbrm mongo create --index test1.index_m1 --expire-sec 3600 --key \"field1:-1\"\n"
    echo -en "                     --key \"field2:-1\"\n"
    echo -en "\n"

    return 0
  }

  _mongo_create_args () {

    [[ $DEBUG && $DEBUG == true ]] && \
      echo -en "(_mongo_create_args args: $@)\n"

    local short_options="U:P:hH:D:t:S:"
    local long_options="database: authdb: conn-options: help" # connection long options
    long_options="$long_options index: unique expire-sec: opt: key: background"

    set -- `getopt -u -q -a -o "$short_options" -l "$long_options" -- "$@"` || \
      error_handled "Invalid parameters"

    if [ $# -lt 2 ] ; then # is there at least one param (--)
      _mongo_create_help
      return 1
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_create_args: Found $# params)\n"

    MONGO_CREATE_INDEX=""
    MONGO_CREATE_UNIQUE=0
    MONGO_CREATE_EXPIRE=""
    MONGO_CREATE_OPTS=""
    MONGO_CREATE_KEYS=""
    MONGO_CREATE_OPT_INDEX=0
    MONGO_CREATE_KEY_INDEX=0
    MONGO_CREATE_BACKGROUND=0

    while [ $# -gt 0 ] ; do
      case "$1" in

        -U|-P|-D|-H|--database|--authdb|--conn-options)
          shift
          # do nothing
          ;;

        --index)
          [ -n $MONGO_CREATE_INDEX ] && \
            error_handled "Error: --index option used multiple times"
          [ -z "$2" ] && \
            error_handled "Error: invalid value for param --index"

          MONGO_CREATE_INDEX=$2
          shift
          ;;
        --unique)
          MONGO_CREATE_UNIQUE=1
          ;;
        --expire-sec)
          MONGO_CREATE_EXPIRE="$2"
          shift
          ;;
        --background)
          MONGO_CREATE_BACKGROUND=1
          ;;
        --opt)
          MONGO_CREATE_OPTS[$MONGO_CREATE_OPT_INDEX]="$2"
          let MONGO_CREATE_OPT_INDEX++
          shift
          ;;
        --key)
          MONGO_CREATE_KEYS[$MONGO_CREATE_KEY_INDEX]="$2"
          let MONGO_CREATE_KEY_INDEX++
          shift
          ;;
        -h|--help)
          _mongo_create_help
          return 1
          ;;
        --)
          ;;
        *)
          error_generate "Invalid parameter $1."
          ;;

      esac

      shift
    done

    if [ -z "$MONGO_CREATE_INDEX" ] ; then
      error_generate "--index option not present."
    fi

    if [ $MONGO_CREATE_KEY_INDEX -lt 1 ] ; then
      error_generate "Missing --key option."
    fi

    return 0
  }

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  _mongo_create_args "$@" || error_handled ""

  unset -f _mongo_create_args
  unset -f _mongo_create_help

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"


  if [ -n "${MONGO_CREATE_INDEX}" ] ; then

    local coll=""
    local key=""
    local opts="{"
    local keys="{"
    local i=0
    local pos=0

    coll=$(echo ${MONGO_CREATE_INDEX} | cut -d'.' -f 1)
    key=$(echo ${MONGO_CREATE_INDEX} | cut -d'.' -f 2)

    [ "${coll}" == "${key}" ] && error_generate "Error: missing key name on INAME argument."

    if [ $MONGO_CREATE_OPT_INDEX -gt 0 ] ; then

      for i in ${!MONGO_CREATE_OPTS[@]}
      do

        if [ $pos -eq 0 ] ; then
          opts="${opts}${MONGO_CREATE_OPTS[$i]}"
        else
          opts="${opts}, ${MONGO_CREATE_OPTS[$i]}"
        fi

        let pos++

      done # End for opts

    fi

    if [ $MONGO_CREATE_UNIQUE -eq 1 ] ; then

      if [ $pos -eq 0 ] ; then
        opts="${opts} \"unique\": true"
      else
        opts="${opts}, \"unique\": true"
      fi

      let pos++

    fi

    if [ -n "${MONGO_CREATE_EXPIRE}" ] ; then

      if [ $pos -eq 0 ] ; then
        opts="${opts} \"expireAfterSeconds\": ${MONGO_CREATE_EXPIRE}"
      else
        opts="${opts}, \"expireAfterSeconds\": ${MONGO_CREATE_EXPIRE}"
      fi

      let pos++

    fi

    if [ $MONGO_CREATE_BACKGROUND -eq 1 ] ; then

      if [ $pos -eq 0 ] ; then
        opts="${opts} \"background\": true"
      else
        opts="${opts}, \"background\": true"
      fi

    fi

    opts="${opts} }"

    pos=0
    # Create keys
    for i in ${!MONGO_CREATE_KEYS[@]}
    do

      if [ $pos -eq 0 ] ; then
        keys="${keys} ${MONGO_CREATE_KEYS[$i]}"
      else
        keys="${keys}, ${MONGO_CREATE_KEYS[$i]}"
      fi

      let pos++

    done # end for keys

    keys="${keys} }"
    keys=$(printf '%s' ${keys})

    commons_mongo_create_index_file "${coll}" "${key}" "${keys}" "${opts}" ||
      error_handled "Error on create index ${key} for collection ${coll}."

    out_handler_print "Created index ${key} for collection ${coll}."
    out_handler_print "Now, you can compile it with compile command."

  fi

  return 0
}
# mongo_mongo_create_end

# mongo_mongo_drop
mongo_drop () {

  # Shift first two input param
  shift 2

  _mongo_drop_help () {

    echo -en "[--all-indexes]          Drop all indexes present on database (not _id_).\n"
    echo -en "[--index INAME]          Index name to drop.\n"
    echo -en "                         This option is not usable multiple time.\n"
    echo -en "                         INAME contains name of the collection where drop all\n"
    echo -en "                         indexes of a specific collection or name of the collection \n"
    echo -en "                         with key name separated with a point.\n"

    echo -en "\n"

    return 0
  }

  _mongo_drop_args () {

    [[ $DEBUG && $DEBUG == true ]] && \
      echo -en "(_mongo_drop_args args: $@)\n"

    local short_options="U:P:hH:D:t:S:"
    local long_options="database: authdb: conn-options: help" # connection long options
    long_options="$long_options all-indexes index:"

    set -- `getopt -u -q -a -o "$short_options" -l "$long_options" -- "$@"` || \
      error_handled "Invalid parameters"

    if [ $# -lt 2 ] ; then # is there at least one param (--)
      _mongo_drop_help
      return 1
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_create_args: Found $# params)\n"

    MONGO_DROP_INDEX=""
    MONGO_DROP_ALL_INDEXES=0

    while [ $# -gt 0 ] ; do
      case "$1" in

        -U|-P|-D|-H|--database|--authdb|--conn-options)
          shift
          # do nothing
          ;;

        --index)
          [ -n $MONGO_DROP_INDEX ] && \
            error_handled "Error: --index option used multiple times"
          [ -z "$2" ] && \
            error_handled "Error: invalid value for param --index"

          MONGO_DROP_INDEX=$2
          shift
          ;;
        --all-indexes)
          MONGO_DROP_ALL_INDEXES=1
          ;;
        -h|--help)
          _mongo_drop_help
          return 1
          ;;
        --)
          ;;
        *)
          error_generate "Invalid parameter $1."
          ;;

      esac

      shift
    done

    return 0
  }

  _mongo_check_status

  _mongo_help_message="print_help"

  _mongo_connections_args "$@" || error_handled ""

  _mongo_drop_args "$@" || error_handled ""

  commons_mongo_check_vars || error_handled ""

  mongo_set_auth_var "$MONGO_DB" "$MONGO_USER" "$MONGO_PWD" "$MONGO_HOST" "${MONGO_AUTHDB}"

  commons_mongo_check_connection || \
    error_handled "mongo client was unable to connect to DB with supplied credentials."

  _mongo_drop || error_handled ""

  return 0
}
# mongo_mongo_drop_end

##################################################################
# Internal functions
##################################################################

# mongo__mongo_init
#   Internal function called on initialization of the mongo module.
#
#   Mongo module is usable when SQLCA variable contains mongo string.
#   So, if mongo module is enabled then these check are done:
#   * verify presence of mysql client program
#   * check if MONGO_USER variable is set. This variable define user to use
#     on connection to database.
#   * check if MONGO_PWD variable is set. This variable define password to use
#     on connection to database.
#   * check if defined MONGO_DB variable. This variable define name of the
#     schema to use on connection.
#   * check if defined MONGO_DIR variable. This variable define path where
#     save/retrieve files to compile.
_mongo_init () {

  if [[ ! -z "$SQLCA"  && "$SQLCA" =~ .*mongo.* ]] ; then

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_init: Check requirements of the mongo module.)\n"

    commons_mongo_check_client || error_handled ""

    if [ -z $MONGO_TMZ ] ; then
      MONGO_TMZ='UTC'
    fi

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_init: All requirements are present. Continue my work.)\n"

    mongo_status="1"

  else

    [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_init: Nothing to do.)\n"

  fi

  return 0
}
# mongo__mongo_init_end

# mongo__mongo_check_status
#
#   Check status of the mongo module.
# RETURN VALUE
#   0 if module is enable.
#   exit if not enabled.
_mongo_check_status () {

  if [ x"$mongo_status" = x"0" ] ; then
    error_generate "mongo is not enable. Enable it with SQLCA variable"
  fi

  return 0
}
# mongo__mongo_check_status_end

#****f* mongo/_mongo_connections_args
# FUNCTION
#   Parse command line and define environment variables.
# DESCRIPTION
#   Available commands line are:
#   * -U [user]           Override username variable used on connection. If not present it is used
#                         MONGO_USER variable from configuration file.
#   * -P [pwd]            Override password variable used on connection. If not present it is used
#                         MONGO_PWD variable from configuration file.
#   * -D [dir path]       To define path where save/retrieve files to download/compile. This option
#                         override MONGO_DIR variable of configuration file.
#   * -H                  Override database host. If not present it is used MONGO_HOST variable
#                         from configuration file.
#   * --database [db]     Override database name variable used on connection. If not present it is used
#                         MONGO_DB variable from configuration file.
#   * --authdb [db]       Override authentication database variable used on connection initialization.
#                         If not present it is used MONGO_AUTHDB variable from configuration file.
#   * --conn-options [option]
#                         Permit to configure extra connection parameters. This option could be used
#                         more of one time.
#   * -h                  Show help message
# SOURCE
_mongo_connections_args () {

  [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_connections_args args: $@)\n"

  local short_options="U:P:hH:D:t:S:"
  local long_options="database: authdb: conn-options:  help"

  $(set -- $(getopt -u -q -o "$short_options" -l "$long_options" -- "$@")) || \
    error_handled "Invalid parameters"

  [ $# -lt 1 ] && return 0 # is there at least one param (--)

  local MONGO_EXTRAS_ENABLE=0

  while [ $# -gt 0 ] ; do
    case "$1" in

      -U) MONGO_USER="$2";shift;;
      -P) MONGO_PWD="$2";shift;;
      -D) MONGO_DIR="$2";shift;;
      -H) MONGO_HOST="$2";shift;;
      --database)
        MONGO_DB="$2"
        shift
        ;;
      --authdb)
        MONGO_AUTHDB="$2"
        shift
        ;;
      --conn-options)
        if [ $MONGO_EXTRAS_ENABLE -eq 0 ] ; then
          MONGO_EXTRAS_ENABLE=1
          MONGO_EXTRA_OPTIONS="$2"
        else
          MONGO_EXTRA_OPTIONS="$MONGO_EXTRA_OPTIONS $2"
        fi
        shift
        ;;
      --help|-h)
        if [ -n "$_mongo_help_message" ] ; then
          _mongo_connection_help
          return 0
        fi
        return 1
        ;;
      *|--)
        ;;

    esac

    shift

  done

  return 0
}
#***


#****f* mongo/_mongo_connection_help
# FUNCTION
#   Internal function that print help message of connection options.
# SOURCE
_mongo_connection_help () {

  echo "
[-P mongo_pwd]           Override MONGO_PWD variable.
[-U mongo_user]          Override MONGO_USER with username of the connection.
[-H mongo_host]          Override MONGO_HOST with host of the database.
[-D mongo_dir]           Override MONGO_DIR directory where save/retrieve script/functions, etc.
[--database db]          Override MONGO_DB variable for database name.
[--conn-options opts]    Override MONGO_EXTRA_OPTIONS variable for enable extra connection options.
[--authdb db]            Override MONGO_AUTHDB variable for set authentication database.
"

  return 0
}
#***

# mongo__mongo_compile_args
_mongo_compile_args () {

  [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_compile_args args: $@)\n"

  local short_options="U:P:hH:D:t:S:"
  local long_options="database: authdb: conn-options:  help"

  # mongo__mongo_compile_help
  _mongo_compile_help () {
    echo -en "[--file file]            Compile a particular file. (Use ABS Path or relative path from current dir.)\n"
    echo -en "[--indexes]              Compile all indexes not already present.\n"
    echo -en "[--index INAME]          Compila a particular index.\n"
    echo -en "                         This option could be used multiple time.\n"
    echo -en "                         INAME contains name of the collection where drop all\n"
    echo -en "                         indexes of a specific collection or name of the collection \n"
    echo -en "                         with key name separated with a point.\n"

    return 0
  }
  # mongo__mongo_compile_help_end

  long_options="$long_options file: indexes index:"

  $(set -- $(getopt -u -q -o "$short_options" -l "$long_options" -- "$@")) || \
    error_handled "Invalid parameters"

  if [ $# -lt 1 ] ; then
    _mongo_compile_help
    return 1
  fi

  MONGO_COMPILE_FILE=""
  MONGO_COMPILE_KEY_INDEX=0
  MONGO_COMPILE_KEYS=""
  MONGO_COMPILE_ALL_INDEXES=0

  while [ $# -gt 0 ] ; do
    case "$1" in

      -U|-P|-D|-H|--database|--authdb)
        # do nothing
        shift
        ;;
      --conn-options)
        # do nothing
        shift
        ;;
      --indexes)
        MONGO_COMPILE_ALL_INDEXES=1
        ;;
      --index)
        MONGO_COMPILE_KEYS[$MONGO_COMPILE_KEY_INDEX]="$2"
        let MONGO_COMPILE_KEY_INDEX++
        shift
        ;;
      --file)
        MONGO_COMPILE_FILE="$2"
        shift
        ;;
      --help|-h)
        if [ -n "$_mongo_help_message" ] ; then
          _mongo_connection_help
          return 0
        fi
        return 1
        ;;
      *|--)
        ;;

    esac

    shift
  done

  unset -f _mongo_compile_help

  return 0
}
# mongo__mongo_compile_args_end

# mongo__mongo_compile
_mongo_compile () {

  local f=""

  [[ $DEBUG && $DEBUG == true ]] && echo -en "(_mongo_compile args: $@)\n"

  # Compile single file
  if [ -n "${MONGO_COMPILE_FILE}" ] ; then

    # TODO: Check when use MONGO_INITRC
    commons_mongo_compile_file "$MONGO_COMPILE_FILE" "File $MONGO_COMPILE_FILE" "1" || \
      error_handled "Error on compile file $MONGO_COMPILE_FILE."

  fi

  if [ $MONGO_COMPILE_ALL_INDEXES -eq 1 ] ; then

    commons_mongo_compile_all_idxs "" || \
      error_handled "Error on compile all indexes."

  fi

  if [ $MONGO_COMPILE_KEY_INDEX -gt 0 ] ; then

    for key in "${!MONGO_COMPILE_KEYS[@]}"
    do

      local f=$(basename ${MONGO_COMPILE_KEYS[$key]})
      f=$(echo $f | sed -e 's/\.js$//g')

      local coll=$(echo ${f} | cut -d'.' -f 1)
      local key=$(echo ${f} | cut -d'.' -f 2)
      local indexesdir="${MONGO_DIR}/indexes"

      if [ "${coll}" == "${key}" ] ; then

        for i in ${indexesdir}/${coll}.*.js ; do

          if [ ! -f "${i}" ] ; then
            continue
          fi

          f=$(basename "${i}" | sed -e 's/\.js$//g')

          commons_mongo_compile_idx "${indexesdir}/${f}.js" "indexes of collection ${coll}" || \
            error_handled "Error on compile index ${MONGO_COMPILE_KEYS[$key]}"

        done # end for i

      else

        commons_mongo_compile_idx "${indexesdir}/${f}.js" "index" || \
          error_handled "Error on compile index ${MONGO_COMPILE_KEYS[$key]}"

      fi

    done

  fi

  return 0
}
# mongo__mongo_compile_end

# mongo__mongo_show
_mongo_show () {

  if [ $MONGO_SHOW_ALL -eq 1 ] ; then

    _mongo_show_indexes "" "" "" ${MONGO_SHOW_EXCLUDEID}

    _mongo_show_collections

  fi

  if [ $MONGO_SHOW_ALL_INDEXES -eq 1 ] ; then

    _mongo_show_indexes "" "" "" ${MONGO_SHOW_EXCLUDEID}

  fi

  if [ $MONGO_SHOW_ALL_COLLECTIONS -eq 1 ] ; then

    _mongo_show_collections

  fi

  # Show single collection data
  if [ $MONGO_SHOW_COLL_DESCR -gt 0 ] ; then

    for i in ${!MONGO_SHOW_COLLS[@]}
    do

      _mongo_show_collections ${MONGO_SHOW_COLLS[$i]}

      out_handler_print "\n"

    done

  fi

  # Show single index data
  if [ $MONGO_SHOW_INDEX_DESCR -gt 0 ] ; then

    local coll=""
    local key=""
    local show_detail=1
    for i in ${!MONGO_SHOW_INDEX[@]}
    do

      coll=""
      key=""
      show_detail=1

      coll=$(echo ${MONGO_SHOW_INDEX[$i]} | cut -d'.' -f 1)
      key=$(echo ${MONGO_SHOW_INDEX[$i]} | cut -d'.' -f 2)

      if [ $coll = $key ] ; then
        # POST: not . on string.
        key=""
        show_detail=0
      fi

      _mongo_show_indexes "${coll}" "${key}" ${show_detail} ${MONGO_SHOW_EXCLUDEID}

      out_handler_print "\n"

    done

  fi

  return 0
}
# mongo__mongo_show_end

# mongo__mongo_show_collections
_mongo_show_collections () {

  local collection="$1"
  local i=0
  local coll_name=25
  local stosize_name=20
  local counter=0
  local count_name=20

  commons_mongo_stats "${collection}" "collection" || \
    error_handled "Error on retrieve collections list."

  local n_colls=${#mongo_stats[@]}

  if [ $n_colls -eq 0 ] ; then

    out_handler_print "No collections available."

  else

    # Number of indexes must be divided by 11
    # number of entries data for collection
    # because I use an associative array.
    n_colls=$((n_colls/11))

    if [[ -n "${collection}" ]] ; then

      # POST: show detail of single collection
      #       with a vertical table.
      out_ttitle="Detail of collection ${collection}"

      out_headers[0]="COLLECTION"
      out_headers[1]="SHARDED"
      out_headers[2]="CAPPED"
      out_headers[3]="N. INDEX"
      out_headers[4]="STORAGE SIZE (KB)"
      out_headers[5]="PRIMARY"
      out_headers[6]="N. DOCS"
      out_headers[7]="TOTAL INDEX SIZE (KB)"
      out_headers[8]="AVERAGE OBJ SIZE (KB)"
      out_headers[9]="SIZE (KB)"
      out_headers[10]="SHARDED NODES"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"
      out_el_pre[5]="\e[1;30m"
      out_el_pre[6]="\e[1;29m"
      out_el_pre[7]="\e[1;36m"
      out_el_pre[8]="\e[1;37m"
      out_el_pre[9]="\e[1;34m"
      out_el_pre[10]="\e[1;33m"

      out_el_post[0]="\e[m"

      out_htabs_mode="htabs"
      out_prepost_mode="any"
      out_vertical=1
      out_vert_sep="=============================================================================================================================="

      local coll=${mongo_stats[$i, 0]}
      local storsize=${mongo_stats[$i, 1]}
      local sharded=${mongo_stats[$i, 2]}
      local primary=${mongo_stats[$i, 3]}
      local count=${mongo_stats[$i, 4]}
      local n_idx=${mongo_stats[$i, 5]}
      local totIdx=${mongo_stats[$i, 6]}
      local capped=${mongo_stats[$i, 7]}
      local avgObjSize=${mongo_stats[$i, 8]}
      local size=${mongo_stats[$i, 9]}
      local shardedNodes=${mongo_stats[$i, 10]}

      eval "unset row${counter}"
      out_rows[$counter]="row${counter}"

      eval "row${counter}[0]=\"${coll}\""
      eval "row${counter}[1]=\"${sharded}\""
      eval "row${counter}[2]=\"${capped}\""
      eval "row${counter}[3]=\"${n_idx}\""
      eval "row${counter}[4]=\"${storsize}\""
      eval "row${counter}[5]=\"${primary}\""
      eval "row${counter}[6]=\"${count}\""
      eval "row${counter}[7]=\"${totIdx}\""
      eval "row${counter}[8]=\"${avgObjSize}\""
      eval "row${counter}[9]=\"${size}\""
      eval "row${counter}[10]=\"${shardedNodes}\""

      out_tabs[0]="30"
      out_htabs[0]="30"

      out_handler_print_arr

    else # else of if -n detail

      out_hsep=1
      out_prepost_mode="any"
      out_htabs_mode="tabs"

      if [ -n "${collection}" ] ; then
        out_ttitle="Collection ${collection}"
      else
        out_ttitle="Collections"
      fi

      out_headers[0]="COLLECTION"
      out_headers[1]="SHARDED"
      out_headers[2]="N. INDEX"
      out_headers[3]="STORAGE SIZE (KB)"
      out_headers[4]="PRIMARY"
      out_headers[5]="N. DOCS"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"
      out_el_pre[5]="\e[1;29m"

      out_el_post[0]="\e[m"

      for ((i=0; i<${n_colls}; i++)) ; do

        local coll=${mongo_stats[$i, 0]}
        local storsize=${mongo_stats[$i, 1]}
        local sharded=${mongo_stats[$i, 2]}
        local primary=${mongo_stats[$i, 3]}
        local count=${mongo_stats[$i, 4]}
        local n_idx=${mongo_stats[$i, 5]}

        # Clean previous row array
        eval "unset row${counter}"
        out_rows[$counter]="row"${counter}

        eval "row${counter}[0]=\"${coll}\""
        eval "row${counter}[1]=\"${sharded}\""
        eval "row${counter}[2]=\"${n_idx}\""
        eval "row${counter}[3]=\"${storsize}\""
        eval "row${counter}[4]=\"${primary}\""
        eval "row${counter}[5]=\"${count}\""

        # Check if needed enlarge size of first column
        if [ ${#coll} -ge $coll_name ] ; then
          coll_name=$((${#coll}+1))
        fi
        if [ ${#storsize} -ge $stosize_name ] ; then
          stosize_name=$((${#stosize}+1))
        fi
        if [ ${#count} -ge $count_name ] ; then
          count_name=$((${#count}+1))
        fi

        let counter++

      done

      out_tabs[0]="$coll_name"
      out_tabs[1]="9"
      out_tabs[2]="9"
      out_tabs[3]="$stosize_name"
      out_tabs[4]="10"
      out_tabs[5]="$count_name"

      out_handler_print_arr
      out_handler_print "\nFound ${n_colls} collections."

    fi # end if detail

  fi

  out_handler_clean

  return 0
}
# mongo__mongo_show_collections_end

# mongo__mongo_show_indexes
_mongo_show_indexes () {

  local collection="$1"
  local keyname="$2"
  local detail="$3"
  local exclude_id=${4:-0}
  local i=0
  local coll_name=25
  local key_name=25
  local keys_name=30

  commons_mongo_get_indexes_list "${collection}" "${keyname}" ${exclude_id} || \
    error_handled "Error on retrieve indexes list."

  local n_indexes=${#mongo_indexes[@]}

  if [ $n_indexes -eq 0 ] ; then

    out_handler_print "No indexes available."

  else

    # Number of indexes must be divided by 7.
    # number of entries data for index
    # because I use an associative array.
    n_indexes=$((n_indexes/7))

    if [[ -n ${detail} ]] ; then

      # POST: show detail of single collection
      #       with a vertical table.
      out_ttitle="Index details for collection ${collection} (${n_indexes})"
      [[ -n "${keyname}" ]] && out_ttitle="${out_ttitle} and key ${keyname}"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"
      out_el_pre[5]="\e[1;29m"
      out_el_post[0]="\e[m"

      out_headers[0]="COLLECTION"
      out_headers[1]="KEY NAME"
      out_headers[2]="NUM. KEYS"
      out_headers[3]="KEYS"
      out_headers[4]="INDEX SIZE (KB)"
      out_headers[5]="INDEX OPTIONS"

      out_htabs_mode="htabs"
      out_prepost_mode="any"
      out_vertical=1
      out_vert_sep="=============================================================================================================================="

      local counter=0

      for ((i=0; i<${n_indexes}; i++)) ; do

        local kcoll=${mongo_indexes[$i, 0]}
        local kname=${mongo_indexes[$i, 1]}
        local n_keys=${mongo_indexes[$i, 3]}
        local keys=${mongo_indexes[$i, 4]}
        local idxsize=${mongo_indexes[$i, 5]}
        local idxopts=${mongo_indexes[$i, 6]}

        # Clean previous row array
        eval "unset row${counter}"
        out_rows[$counter]="row"${counter}

        eval "row${counter}[0]=\"${kcoll}\""
        eval "row${counter}[1]=\"${kname}\""
        eval "row${counter}[2]=\"${n_keys}\""
        eval "row${counter}[3]=\"${keys}\""
        eval "row${counter}[4]=\"${idxsize}\""
        eval "row${counter}[5]=\"${idxopts}\""

        let counter++

      done

      out_tabs[0]="30"
      out_htabs[0]="30"

      out_handler_print_arr

    else # else of if -n detail

      out_hsep=1
      out_prepost_mode="any"
      out_htabs_mode="tabs"

      if [ -n "${collection}" ] ; then
        out_ttitle="Index details for collection ${collection} (${n_indexes})"
      else
        out_ttitle="Indexes (${n_indexes})"
      fi
      out_headers[0]="COLLECTION"
      out_headers[1]="KEY NAME"
      out_headers[2]="# KEYS"
      out_headers[3]="KEYS"
      out_headers[4]="INDEX SIZE (KB)"

      out_el_pre[0]="\e[1;33m"
      out_el_pre[1]="\e[1;32m"
      out_el_pre[2]="\e[1;31m"
      out_el_pre[3]="\e[1;34m"
      out_el_pre[4]="\e[1;35m"

      out_el_post[0]="\e[m"

      local counter=0

      for ((i=0; i<${n_indexes}; i++)) ; do

        local kcoll=${mongo_indexes[$i, 0]}
        local kname=${mongo_indexes[$i, 1]}
        local keys=${mongo_indexes[$i, 2]}
        local n_keys=${mongo_indexes[$i, 3]}
        local idxsize=${mongo_indexes[$i, 5]}

        # Clean previous row array
        eval "unset row${counter}"
        out_rows[$counter]="row"${counter}

        eval "row${counter}[0]=\"${kcoll}\""
        eval "row${counter}[1]=\"${kname}\""
        eval "row${counter}[2]=\"${n_keys}\""
        eval "row${counter}[3]=\"${keys}\""
        eval "row${counter}[4]=\"${idxsize}\""

        # Check if needed enlarge size of first column
        if [ ${#kcoll} -ge $coll_name ] ; then
          coll_name=$((${#kcoll}+1))
        fi
        if [ ${#kname} -ge $key_name ] ; then
          key_name=$((${#kname}+1))
        fi

        if [ ${#keys} -ge $keys_name ] ; then
          keys_name=$((${#keys}+1))
        fi

        let counter++

      done

      out_tabs[0]="$coll_name"
      out_tabs[1]="$key_name"
      out_tabs[2]="8"
      out_tabs[3]="$keys_name"
      out_tabs[4]="20"

      out_handler_print_arr

    fi

    out_stdout_clean

  fi

  return 0
}
# mongo__mongo_show_indexes_end

# mongo__mongo_drop
_mongo_drop () {

  local ans=""
  local i=0
  local kcoll=""
  local kname=""

  if [ $MONGO_DROP_ALL_INDEXES -eq 1 ] ; then

    commons_mongo_get_indexes_list "" "" 1 || \
      error_handled "Error on retrieve indexes list."

    local n_indexes=${#mongo_indexes[@]}

    if [ $n_indexes -eq 0 ] ; then

      out_handler_print "No indexes found to drop. Nothing to do."

    else

      n_indexes=$((n_indexes/7))

      for ((i=0; i<${n_indexes}; i++)) ; do

        kcoll=${mongo_indexes[$i, 0]}
        kname=${mongo_indexes[$i, 1]}

        out_handler_print "Dropping index ${kname} of collection ${kcoll}..."

        commons_mongo_drop_index "${kcoll}" "${kname}"
        ans=$?

        if [ $ans -eq 0 ] ; then
          out_handler_print "OK"
        fi

      done # end for i

    fi # end if $n_indexes

  fi

  if [ -n "$MONGO_DROP_INDEX" ] ; then

    kcoll=$(echo ${MONGO_DROP_INDEX} | cut -d'.' -f 1)
    kname=$(echo ${MONGO_DROP_INDEX} | cut -d'.' -f 2)

    if [ $kcoll = $kname ] ; then
      kname=""
      out_handler_print "Dropping all index of collection ${kcoll}..."
    else
      out_handler_print "Dropping index ${kname} of collection ${kcoll}..."
    fi

    commons_mongo_drop_index "${kcoll}" "${kname}"
    ans=$?

    if [ $ans -eq 0 ] ; then
      out_handler_print "OK"
    fi

  fi

  return 0
}
# mongo__mongo_drop_end

# vim: syn=sh filetype=sh
