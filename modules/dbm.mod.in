#!/bin/bash
#------------------------------------------------
# Author(s): Geaaru, geaaru@gmail.com
# $Id$
# License: GPL 2.0
#------------------------------------------------

name="dbm"
dbm_authors="Geaaru"
dbm_creation_date="May 5, 2013"
dbm_version="@PACKAGE_VERSION@"


dbm_schema=@SHAREDIR@/dbm_sqlite_schema.sql

# List of tables of sqlite database used by dbm modules.
dbm_tables="
  ScriptTypes
  DatabaseAdapters
  Releases
  Branches
  ReleasesDependencies
  Scripts
  ScriptRelInhibitions
  ScriptRelDedicated
  Profiles
  Extensions
"

# dbm_dbm_version
dbm_version() {
   echo -en "Version: ${dbm_version}\n"

   return 0
}
# dbm_dbm_version_end

# dbm_dbm_long_help
dbm_long_help () {

   echo -en "===========================================================================\n"
   echo -en "Module [dbm]:\n"
   echo -en "Author(s): ${dbm_authors}\n"
   echo -en "Created: ${dbm_creation_date}\n"
   echo -en "Version: ${dbm_version}\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "\tlong_help               Show long help informations\n"
   echo -en "\tshow_help               Show command list.\n"
   echo -en "\tversion                 Show module version.\n"
   echo -en "\tshow_releases           Show releases.\n"
   echo -en "\tshow_adapters           Show database adapters\n"
   echo -en "\tshow_script_types       Show script types.\n"
   echo -en "\tshow_scripts            Show scripts.\n"
   echo -en "\tshow_rel_dep            Show release dependencies.\n"
   echo -en "\tshow_inhibit_scripts    Show inhibited scripts.\n"
   echo -en "\tshow_rel_ded_scripts    Show release dedicated scripts.\n"
   echo -en "\tinsert_inhibit_script   Insert a new inhibit script relationship.\n"
   echo -en "\tremove_inhibit_script   Remove an inhibit script relationship.\n"
   echo -en "\tinsert_ded_script       Insert a new release dedicated script relationship.\n"
   echo -en "\tremove_ded_script       Remove a release dedicated script relationship.\n"
   echo -en "\tinsert_release          Insert a new release.\n"
   echo -en "\tmove_release            Move release position.\n"
   echo -en "\tupdate_release          Update a release data.\n"
   echo -en "\tremove_release          Remove a release.\n"
   echo -en "\tinsert_script_type      Insert a new script type.\n"
   echo -en "\tinsert_rel_dep          Insert a new release dependency.\n"
   echo -en "\tremove_rel_dep          Remove release dependency.\n"
   echo -en "\tinsert_script           Insert a new script.\n"
   echo -en "\tupdate_script           Update a script by Id.\n"
   echo -en "\tremove_script           Remove script.\n"
   echo -en "\tmove_script             Move script.\n"
   echo -en "\tshow_branches           Show branches.\n"
   echo -en "\tinsert_branch           Insert a new branch.\n"
   echo -en "\tshow_profiles           Show profiles\n"
   echo -en "\tadd_profile             Add a new profile to project.\n"
   echo -en "\tdel_profile             Remove a profile from project.\n"
   echo -en "\tset_profile             Set default profile of the project.\n"
   echo -en "\tinfo                    Show informations about dbm parameters and project.\n"
   echo -en "\tshell                   Enter on sqlite dbm database.\n"
   echo -en "\tupgrade                 Check if dbrm database is align to last release and\n"
   echo -en "\t                        create new tables.\n"
   echo -en "\tinitenv                 Create a new empty dbrm database and a dbrm.conf\n"
   echo -en "\t                        on current directory.\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "===========================================================================\n"

   return 0
}
# dbm_dbm_long_help_end

# dbm_dbm_show_help
dbm_show_help () {

   echo -en "===========================================================================\n"
   echo -en "Module [dbm]:\n"
   echo -en "---------------------------------------------------------------------------\n"
   echo -en "\tlong_help               Show long help informations\n"
   echo -en "\tshow_releases           Show releases.\n"
   echo -en "\tshow_adapters           Show database adapters\n"
   echo -en "\tshow_script_types       Show script types.\n"
   echo -en "\tshow_scripts            Show scripts.\n"
   echo -en "\tshow_rel_dep            Show release dependencies.\n"
   echo -en "\tshow_inhibit_scripts    Show inhibited scripts.\n"
   echo -en "\tshow_rel_ded_scripts    Show release dedicated scripts.\n"
   echo -en "\tinsert_inhibit_script   Insert a new inhibit script relationship.\n"
   echo -en "\tremove_inhibit_script   Remove an inhibit script relationship.\n"
   echo -en "\tinsert_ded_script       Insert a new release dedicated script relationship.\n"
   echo -en "\tremove_ded_script       Remove a release dedicated script relationship.\n"
   echo -en "\tinsert_release          Insert a new release.\n"
   echo -en "\tmove_release            Move release position.\n"
   echo -en "\tupdate_release          Update a release data .\n"
   echo -en "\tremove_release          Remove a release.\n"
   echo -en "\tinsert_script_type      Insert a new script type.\n"
   echo -en "\tinsert_rel_dep          Insert a new release dependency.\n"
   echo -en "\tremove_rel_dep          Remove release dependency.\n"
   echo -en "\tinsert_script           Insert a new script.\n"
   echo -en "\tupdate_script           Update a script by Id.\n"
   echo -en "\tremove_script           Remove script.\n"
   echo -en "\tmove_script             Move script.\n"
   echo -en "\tshow_branches           Show branches.\n"
   echo -en "\tinsert_branch           Insert a new branch.\n"
   echo -en "\tshow_profiles           Show profiles\n"
   echo -en "\tadd_profile             Add a new profile to project.\n"
   echo -en "\tdel_profile             Remove a profile from project.\n"
   echo -en "\tset_profile             Set default profile of the project.\n"
   echo -en "\tinfo                    Show informations about dbm parameters and project.\n"
   echo -en "\tshell                   Enter on sqlite dbm database.\n"
   echo -en "\tupgrade                 Check if dbrm database is align to last release and\n"
   echo -en "\t                        create new tables.\n"
   echo -en "\tinitenv                 Create a new empty dbrm database and a dbrm.conf\n"
   echo -en "\t                        on current directory.\n"
   echo -en "===========================================================================\n"

   return 0
}
# dbm_dbm_show_help_end

# dbm_dbm_info
dbm_info () {

  local fields="LOCAL_DIR
    LOCAL_CONFIG_FILE
    MODULES_DIR
    SQLCA
    DRM_DB
    DBM_HISTORY
    DRM_PROFILE
    DRM_PROFILES_PATH
  "

  if [[ ! -z "$SQLCA"  && "$SQLCA" =~ .*mariadb.* ]] ; then
    fields="${fields}
      MARIADB_USER
      MARIADB_PWD
      MARIADB_DB
      MARIADB_HOST
      MARIADB_DIR
      MARIADB_TMZ
      MARIADB_COMPILE_FILES_EXCLUDED
      MARIADB_EXTRA_OPTIONS
      MARIADB_ENABLE_COMMENTS
    "
  fi

  if [[ ! -z "$SQLCA"  && "$SQLCA" =~ .*sqlite.* ]] ; then
    fields="${fields}
      SQLITEDB
    "
  fi

  if [[ ! -z "$SQLCA"  && "$SQLCA" =~ .*oracle.* ]] ; then
    fields="${fields}
      ORACLE_USER
      ORACLE_PWD
      ORACLE_SID
      ORACLE_DIR
      ORACLE_COMPILE_FILES_EXCLUDED
      TNS_ADMIN
    "
  fi

  # TODO: use output modules.
  for i in $fields ; do
    echo -en "$i = ${!i}\n"
  done

  return 0
}
# dbm_dbm_info_end


# dbm_dbm_initenv
dbm_initenv () {

  local ans=0
  local v=""
  local dbrm_profiles_options=""

  shift 2

  _dbm_check_initenv_args "$@" || return 1

  if [ -f $DBM_INIT_DIR/dbrm.conf ] ; then
    out_handler_print "File dbrm.conf is already present. I do nothing."
    ans=1
  else

    if [ -e $DBM_INIT_DIR/dbrm.db ] ; then
      out_handler_print "File $DBM_INIT_DIR/dbrm.db already exits."
      return 1
    fi

    cp $CONFIG_FILE_STUB $DBM_INIT_DIR/dbrm.conf || error_handled \
      "Unexpected error on copy dbrm.conf stub file to local directory."

    if [ $DBM_INIT_PROFILES -eq 1 ] ; then

      if [ -d ${DBM_INIT_DIR}/dbrm-profiles ] ; then
        out_handler_print \
          "Profiles directory ${DBM_INIT_DIR}/dbrm-profiles already exits. I do nothing."
        return 1
      fi

      # Create profiles directory
      mkdir ${DBM_INIT_DIR}/dbrm-profiles || error_handled \
        "Error on create ${DBM_INIT_DIR}/dbrm-profiles directory."

      dbrm_profiles_options="DRM_PROFILE=1
DRM_PROFILES_PATH=\${LOCAL_DIR}/dbrm-profiles
"

    fi

    v="# Database Release Manager configuration file
LOCAL_DIR=${DBM_INIT_DIR}
LOCAL_CONFIG_FILE=\${LOCAL_DIR}/dbrm.conf
LOGFILE=\${LOCAL_DIR}/dbrm.log
DRM_DB=${DBM_INIT_DIR}/dbrm.db
${dbrm_profiles_options}
"
    # Create dbrm file
    echo -en "${v}" > ${DBM_INIT_DIR}/dbrm.conf

    . ${DBM_INIT_DIR}/dbrm.conf

    # Create an empty database
    _sqlite_create -c "$DRM_DB" -s "$dbm_schema" || \
      error_handled "Error on create $DRM_DB file."

    _dbm_exts_check_extensions "0" || \
      error_handled "Error on initialize extensions."

    if [ $DBM_INIT_PROFILES -eq 1 ] ; then
      # Create dev.conf profile file
      cp $CONFIG_FILE_STUB ${DBM_INIT_DIR}/dbrm-profiles/dev.conf || error_handled \
        "Unexpected error on copy dbrm.conf stub file to dev.conf profile file."

      # Fix generic options
      sed -i -e 's/LOCAL_DIR=/#LOCAL_DIR=/g' \
        ${DBM_INIT_DIR}/dbrm-profiles/dev.conf || \
        error_handled "Error on comment LOCAL_DIR variable."

      sed -i -e 's/LOCAL_CONFIG_FILE=/#LOCAL_CONFIG_FILE=/g' \
        ${DBM_INIT_DIR}/dbrm-profiles/dev.conf || \
        error_handled "Error on comment LOCAL_CONFIG_FILE variable."

      # Insert dev profile to DRM db.
      dbm_add_profile "dbrm" "add_profile" "--name" "develop" "--file" "dev.conf" "--default" ||
        error_handled "Error on add default profile."

      out_handler_print \
        "Directory is now initialized.\nModify dev.conf file under dbrm-profile directory for complete configuration."

    else

      out_handler_print \
        "Directory is now initialized.\nModify dbrm.conf file for complete configuration."

    fi

  fi

  return $ans
}
# dbm_dbm_initenv_end

# dbm_dbm_shell
dbm_shell () {

  shift 2

  _sqlite_shell -c "$DRM_DB" || error_handled ""

  return 0
}
# dbm_dbm_shell_end
#***

# dbm_dbm_show_profiles
dbm_show_profiles () {

  _dbm_how_many_profiles || error_handled "Unexpected error!"

  local n_profiles=$_sqlite_ans
  local query=""
  local counter=1
  local id_profile=""
  local name=""
  local file=""
  local default_profile=""
  local update_date=""
  local creation_date=""
  local pname_len=30

  [[ $DEBUG && $DEBUG == true ]] && echo -en "N. Profiles: $n_profiles\n"

  if [ x$n_profiles != x0 ] ; then

    query="
      SELECT id_profile,
             profile_name,
             default_profile,
             conf_file,
             creation_date,
             update_date
      FROM Profiles
      ORDER BY id_profile"

    _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID"
    out_headers[1]="PROFILE_NAME"
    out_headers[2]="DEFAULT"
    out_headers[3]="CREATION_DATE"
    out_headers[4]="UPDATE_DATE"
    out_headers[5]="CONFIG_FILE"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;34m"
    out_el_pre[2]="\e[1;35m"
    out_el_pre[3]="\e[1;31m"
    out_el_pre[4]="\e[1;32m"
    out_el_pre[5]="\e[1;36m"

    out_el_post[0]="\e[m"

    out_tabs[0]="10"
    out_tabs[1]="23"
    out_tabs[2]="15"
    out_tabs[3]="23"
    out_tabs[4]="23"
    out_tabs[5]="23"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      id_profile=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      name=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      default_profile=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      file=`echo $row | awk '{split($0,a,"|"); print a[4]}'`
      update_date=`echo $row | awk '{split($0,a,"|"); print a[5]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[6]}'`

      if [ x${default_profile} == x1 ] ; then
        default_profile="*"
      else
        default_profile=" "
      fi

      if [ ${#profile_name} -ge ${pname_len} ] ; then
        pname_len=$((${#profile_name}+1))
      fi

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_profile}\""
      eval "row${counter}[1]=\"${name}\""
      eval "row${counter}[2]=\"${default_profile}\""
      eval "row${counter}[3]=\"${update_date}\""
      eval "row${counter}[4]=\"${creation_date}\""
      eval "row${counter}[5]=\"${file}\""

      let counter++

    done
    unset IFS

    out_tabs[1]="${pname_len}"

    out_handler_print_arr

  else

    out_handler_print "No profiles available."

  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_profiles

# dbm_dbm_show_releases
dbm_show_releases () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM Releases" || error_handled "Unexpected error!"

  local n_rel=$_sqlite_ans
  local id_release=""
  local name=""
  local version=""
  local release_date=""
  local creation_date=""
  local update_date=""
  local id_order=""
  local db_adapter=""
  local id_branch=""
  local directory=""
  local result=1
  local query=""
  local counter=1

  shift 2

  _dbm_show_rel_args "$@" || return $result

  query="
    SELECT id_release,
           name,
           version,
           release_date,
           creation_date,
           update_date,
           id_order,
           db_adapter,
           id_branch,
           directory
    FROM Releases "

  if [ -n "$DBM_BRANCH_ID" ] ; then

    query="$query WHERE id_branch = $DBM_BRANCH_ID"

  fi

  query="$query ORDER BY id_order,id_branch ASC"

  [[ $DEBUG ]] && echo -en "N. Releases: $n_rel\n"

  if [ x$n_rel != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID"
    out_headers[1]="RELEASE_DATE"
    out_headers[2]="VERSION"
    out_headers[3]="UPDATE_DATE"
    out_headers[4]="ADAPTER"
    out_headers[5]="ID_ORDER"
    out_headers[6]="BRANCH"
    out_headers[7]="DIRECTORY"
    out_headers[8]="NAME"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;34m"
    out_el_pre[2]="\e[1;35m"
    out_el_pre[3]="\e[1;36m"
    out_el_pre[4]="\e[1;31m"
    out_el_pre[5]="\e[1;32m"
    out_el_pre[6]="\e[1;38m"
    out_el_pre[7]="\e[1;33m"
    out_el_pre[8]="\e[1;37m"

    out_el_post[0]="\e[m"

    out_tabs[0]="10"
    out_tabs[1]="23"
    out_tabs[2]="10"
    out_tabs[3]="23"
    out_tabs[4]="10"
    out_tabs[5]="10"
    out_tabs[6]="10"
    out_tabs[7]="11"
    out_tabs[8]="10"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      id_release=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      name=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      version=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      release_date=`echo $row | awk '{split($0,a,"|"); print a[4]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[5]}'`
      update_date=`echo $row | awk '{split($0,a,"|"); print a[6]}'`
      id_order=`echo $row | awk '{split($0,a,"|"); print a[7]}'`
      db_adapter=`echo $row | awk '{split($0,a,"|"); print a[8]}'`
      id_branch=`echo $row | awk '{split($0,a,"|"); print a[9]}'`
      directory=`echo $row | awk '{split($0,a,"|"); print a[10]}'`

      #if [ ${#release_date} -eq 10 ] ; then
      #  release_date_tab="\t\t"
      #else
      #  release_date_tab="\t"
      #fi

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_release}\""
      eval "row${counter}[1]=\"${release_date}\""
      eval "row${counter}[2]=\"${version}\""
      eval "row${counter}[3]=\"${update_date}\""
      eval "row${counter}[4]=\"${db_adapter}\""
      eval "row${counter}[5]=\"${id_order}\""
      eval "row${counter}[6]=\"${id_branch}\""
      eval "row${counter}[7]=\"${directory}\""
      eval "row${counter}[8]=\"${name}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else

    out_handler_print "No releases available."

  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_releases_end

# dbm_dbm_show_scripts
dbm_show_scripts () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM Scripts" || error_handled "Unexpected error!"

  local n_s=$_sqlite_ans
  local counter=0

  [[ $DEBUG ]] && echo -en "N. Scripts: $n_s\n"

  if [ x$n_s != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT id_script,filename,type,active,directory,id_release,id_order,creation_date,update_date FROM Scripts ORDER BY id_release,id_order ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID"
    out_headers[1]="TYPE"
    out_headers[2]="ACTIVE"
    out_headers[3]="DIRECTORY"
    out_headers[4]="ID_RELEASE"
    out_headers[5]="ID_ORDER"
    out_headers[6]="UPDATE_DATE"
    out_headers[7]="FILENAME"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;35m"
    out_el_pre[2]="\e[1;36m"
    out_el_pre[3]="\e[1;31m"
    out_el_pre[4]="\e[1;37m"
    out_el_pre[5]="\e[1;32m"
    out_el_pre[6]="\e[1;33m"
    out_el_pre[7]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="10"
    out_tabs[1]="15"
    out_tabs[2]="10"
    out_tabs[3]="20"
    out_tabs[4]="12"
    out_tabs[5]="10"
    out_tabs[6]="24"
    out_tabs[7]="10"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      id_script=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      filename=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      s_type=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      active=`echo $row | awk '{split($0,a,"|"); print a[4]}'`
      directory=`echo $row | awk '{split($0,a,"|"); print a[5]}'`
      id_release=`echo $row | awk '{split($0,a,"|"); print a[6]}'`
      id_order=`echo $row | awk '{split($0,a,"|"); print a[7]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[8]}'`
      update_date=`echo $row | awk '{split($0,a,"|"); print a[9]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_script}\""
      eval "row${counter}[1]=\"${s_type}\""
      eval "row${counter}[2]=\"${active}\""
      eval "row${counter}[3]=\"${directory}\""
      eval "row${counter}[4]=\"${id_release}\""
      eval "row${counter}[5]=\"${id_order}\""
      eval "row${counter}[6]=\"${update_date}\""
      eval "row${counter}[7]=\"${filename}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No scripts available."
  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_scripts_end

# dbm_dbm_show_script_types
dbm_show_script_types () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM ScriptTypes" || error_handled "Unexpected error!"

  local n_st=$_sqlite_ans
  local counter=0

  [[ $DEBUG ]] && echo -en "N. ScriptTypes: $n_st\n"

  if [ x$n_st != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT code,descr FROM ScriptTypes ORDER BY code ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="CODE"
    out_headers[1]="DESCRIPTION"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="20"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      code=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      descr=`echo $row | awk '{split($0,a,"|"); print a[2]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${code}\""
      eval "row${counter}[1]=\"${descr}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No script types available."
  fi

  out_handler_clean

  return 0
}
# dbm_show_script_types_end

# dbm_dbm_show_rel_dep
dbm_show_rel_dep () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM ReleasesDependencies" || error_handled "Unexpected error!"

  local n_rd=$_sqlite_ans
  local counter=0

  [[ $DEBUG ]] && echo -en "N. ReleasesDependencies: $n_rd\n"

  if [ x$n_rd != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT id_release,id_release_dep,creation_date FROM ReleasesDependencies ORDER BY id_release,id_release_dep ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID_RELEASE"
    out_headers[1]="DEPENDENCY"
    out_headers[2]="CREATION_DATE"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;32m"
    out_el_pre[2]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="15"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      id_release=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      id_release_dep=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[3]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_release}\""
      eval "row${counter}[1]=\"${id_release_dep}\""
      eval "row${counter}[2]=\"${creation_date}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No release dependencies available."
  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_rel_dep

# dbm_dbm_show_inhibit_scripts
dbm_show_inhibit_scripts () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM ScriptRelInhibitions" || error_handled "Unexpected error!"

  local n_r=$_sqlite_ans
  local counter=0

  [[ $DEBUG ]] && echo -en "N. ScriptRelInhibitions: $n_r\n"

  if [ x$n_r != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT id_script,id_release_from,id_release_to,creation_date FROM ScriptRelInhibitions ORDER BY id_script,id_release_to,id_release_from ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID_SCRIPT"
    out_headers[1]="ID_RELEASE_FROM"
    out_headers[2]="ID_RELEASE_TO"
    out_headers[3]="CREATION_DATE"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;32m"
    out_el_pre[2]="\e[1;31m"
    out_el_pre[3]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="16"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      id_script=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      id_release_from=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      id_release_to=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[4]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_script}\""
      eval "row${counter}[1]=\"${id_release_from}\""
      eval "row${counter}[2]=\"${id_release_to}\""
      eval "row${counter}[3]=\"${creation_date}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No scripts available."

  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_inhibit_scripts_end

# dbm_dbm_show_rel_ded_scripts
dbm_show_rel_ded_scripts () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM ScriptRelDedicated" || error_handled "Unexpected error!"

  local n_r=$_sqlite_ans
  local counter=0

  [[ $DEBUG ]] && echo -en "N. ScriptRelDedicated: $n_r\n"

  if [ x$n_r != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT id_script,id_release_from,id_release_to,creation_date FROM ScriptRelDedicated ORDER BY id_script,id_release_to,id_release_from ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID_SCRIPT"
    out_headers[1]="ID_RELEASE_FROM"
    out_headers[2]="ID_RELEASE_TO"
    out_headers[3]="CREATION_DATE"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;32m"
    out_el_pre[2]="\e[1;31m"
    out_el_pre[3]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="15"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      id_script=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      id_release_from=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      id_release_to=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[4]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_script}\""
      eval "row${counter}[1]=\"${id_release_from}\""
      eval "row${counter}[2]=\"${id_release_to}\""
      eval "row${counter}[3]=\"${creation_date}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No scripts available."

  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_rel_ded_scripts_end

# dbm_dbm_show_adapters
dbm_show_adapters  () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM DatabaseAdapters" || error_handled "Unexpected error!"

  local n_st=$_sqlite_ans
  local counter=0

  [[ $DEBUG ]] && echo -en "N. ScriptTypes: $n_st\n"

  if [ x$n_st != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT adapter,descr FROM DatabaseAdapters ORDER BY adapter ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ADAPTER"
    out_headers[1]="DESCRIPTION"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="15"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      adapter=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      descr=`echo $row | awk '{split($0,a,"|"); print a[2]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${adapter}\""
      eval "row${counter}[1]=\"${descr}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No adapters available."

  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_adapters_end

# dbm_dbm_move_release
dbm_move_release () {

  local result=1
  local query=""
  local id_rel_to=""
  local id_rel_from=""
  local id_order=""
  local id_order_to=""
  local id_branch=""
  local id_branch_to=""
  local create_tmp_table=""
  local where_moved_record=""
  local insert2tmp=""
  local delete_rel=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_move_release_args "$@" || return $result

  _dbm_save2history "dbrm dbm move_release $args"

  _dbm_check_if_exist_rel "$DBM_REL_NAME" "$DBM_REL_VERSION_TO" || return $result
  _dbm_check_if_exist_rel "$DBM_REL_NAME" "$DBM_REL_VERSION_FROM" || return $result

  # Retrive id order of the release from
  _dbm_retrieve_field_rel "id_order" "$DBM_REL_NAME" "$DBM_REL_VERSION_FROM"
  id_order=$_sqlite_ans

  # Retrieve id order of the release to
  _dbm_retrieve_field_rel "id_order" "$DBM_REL_NAME" "$DBM_REL_VERSION_TO"
  id_order_to=$_sqlite_ans

  # Retrieve id release from
  _dbm_retrieve_field_rel "id_release" "$DBM_REL_NAME" "$DBM_REL_VERSION_FROM"
  id_rel_from=$_sqlite_ans

  # Retrieve id release to
  _dbm_retrieve_field_rel "id_release" "$DBM_REL_NAME" "$DBM_REL_VERSION_TO"
  id_rel_to=$_sqlite_ans

  # Retrieve id branch from
  _dbm_retrieve_field_rel "id_branch" "$DBM_REL_NAME" "$DBM_REL_VERSION_FROM"
  id_branch=$_sqlite_ans

  # Retrieve id branch to
  _dbm_retrieve_field_rel "id_branch" "$DBM_REL_NAME" "$DBM_REL_VERSION_TO"
  id_branch_to=$_sqlite_ans

  if [ $id_branch_to -ne $id_branch ] ; then
    error_generate "move_release command is not possibile between releases of different branches"
  fi

  _dbm_get_table_schema 'Releases'
  create_tmp_table="$(echo "$_sqlite_ans" | sed 's/Releases/ReleasesTemp/')"

  if [ $DBM_AFTER -eq 1 ] ; then

    if [ $id_order_to -lt $id_order ] ; then

      where_moved_record="WHERE id_branch = $id_branch AND ( id_order > $id_order_to AND id_order < $id_order )"

      insert2tmp="INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               $id_order_to+1 as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases
        WHERE id_release = $id_rel_from
        AND id_branch = $id_branch ;
        INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               id_order+1 as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases $where_moved_record "
      # POST: Move yet release_from to Temporary table

    else

      where_moved_record="WHERE id_order > $id_order AND id_branch = $id_branch "
      # POST: Move yet release_from to Temporary table

      insert2tmp="INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               id_order-1 as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases
        WHERE id_branch = $id_branch
        AND id_order > $id_order AND id_order <= $id_order_to ;
        INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               id_order as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases
        WHERE id_order > $id_order_to AND id_branch = $id_branch ;
        INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               $id_order_to as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases
        WHERE id_release = $id_rel_from
        AND id_branch = $id_branch "

    fi

    t="after"

    result=0

  else

    if [ $id_order_to -lt $id_order ] ; then

      where_moved_record="WHERE id_branch = $id_branch AND id_order < $id_order AND id_order >= $id_order_to "

      insert2tmp="INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               id_order+1 as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases $where_moved_record ;
        INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               $id_order_to as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases
        WHERE id_release = $id_rel_from AND id_branch = $id_branch "
      # POST: Move yet release_from to Temporary table


    else

      where_moved_record="WHERE id_branch = $id_branch AND id_order < $id_order_to AND id_order > $id_order "

      insert2tmp="INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               id_order-1 as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases $where_moved_record ;
        INSERT INTO ReleasesTemp
        SELECT id_release,
               name,
               version,
               release_date,
               creation_date,
               update_date,
               $id_order_to-1 as id_order,
               db_adapter,
               id_branch,
               directory,
               flag_dev
        FROM Releases
        WHERE id_release = $id_rel_from AND id_branch = $id_branch "
      # POST: Move yet release_from to Temporary table

    fi

    t="before"
    result=0

  fi

  delete_rel="DELETE FROM Releases $where_moved_record OR (id_order = $id_order AND id_branch = $id_branch)"

  # Disable PRAGMA options
  SQLITEDB_INIT_SESSION=" "

  query="DROP TABLE IF EXISTS ReleasesTemp ;
    $create_tmp_table ;
    ${insert2tmp} ;
    ${delete_rel} ;
    INSERT INTO Releases
      SELECT id_release,
             name,
             version,
             release_date,
             creation_date,
             DATETIME('now'),
             id_order,
             db_adapter,
             id_branch,
             directory,
             flag_dev
      FROM ReleasesTemp;
    DROP TABLE ReleasesTemp "

  #  SELECT * FROM ReleasesTemp ;
  #  SELECT '-'  ;
  #  SELECT * FROM Releases ;
  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error on update id_order fields."

  # Re-enable PRAGMA options
  unset SQLITEDB_INIT_SESSION

  echo -en "Moved correctly $DBM_REL_NAME v.$DBM_REL_VERSION_FROM ${t} v.$DBM_REL_VERSION_TO.\n"

  return $result
}
# dbm_dbm_move_release_end

# dbm_dbm_update_release
dbm_update_release () {

  local result=1
  local query="UPDATE Releases SET "
  local count=0
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_upd_release_args "$@" || return $result

  _dbm_save2history "dbrm dbm update_release $args"

  if [ -n "$DBM_REL_NAME" ] ; then

    query="$query name = '${DBM_REL_NAME}'"
    let count++

  fi

  if [ -n "$DBM_REL_DATE" ] ; then

    if [ $count -eq 0 ] ; then
      query="$query release_date = '${DBM_REL_DATE}'"
    else
      query="$query , release_date = '${DBM_REL_DATE}'"
    fi
    let count++

  fi

  if [ -n "$DBM_REL_VERSION" ] ; then

    if [ $count -eq 0 ] ; then
      query="$query version = '${DBM_REL_VERSION}'"
    else
      query="$query , version = '${DBM_REL_VERSION}'"
    fi
    let count++

  fi

  if [ -n "$DBM_REL_ADAPTER" ] ; then

    if [ $count -eq 0 ] ; then
      query="$query db_adapter = '${DBM_REL_ADAPTER}'"
    else
      query="$query , db_adapter = '${DBM_REL_ADAPTER}'"
    fi
    let count++

  fi

  if [ -n "$DBM_REL_BRANCH" ] ; then

    if [ $count -eq 0 ] ; then
      query="$query id_branch = ${DBM_REL_BRANCH}"
    else
      query="$query , id_branch = ${DBM_REL_BRANCH}"
    fi
    let count++

  fi

  if [ -n "$DBM_REL_DIR" ] ; then

    if [ $count -eq 0 ] ; then
      query="$query directory = '${DBM_REL_DIR}'"
    else
      query="$query , directory = '${DBM_REL_DIR}'"
    fi
  fi

  query="$query WHERE id_release = $DBM_REL_ID"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Error on update release $DBM_REL_ID."
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Release $DBM_REL_ID updated correctly."
    result=0
  fi

  return $result
}
# dbm_dbm_update_release_end

# dbm_dbm_add_profile
dbm_add_profile () {

  local result=1
  local query=""
  local id_profile=""
  local is_present_default=0
  local update_query=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_add_prof_args "$@" || return $result

  _dbm_save2history "dbrm dbm add_profile $args"

  # Check if present a default profile
  query="
    SELECT COUNT(1)
    FROM Profiles
    WHERE default_profile = 1"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Error on check if is present a default profile"

  if [[ x"$_sqlite_ans" != x"0" && $DBM_PROFILE_DEFAULT -eq 1 ]] ; then
    is_present_default=1
  fi

  if [ $is_present_default -eq 1 ] ; then
    update_query="
      UPDATE Profiles
      SET default_profile = 0, update_date = DATETIME('now')
      WHERE default_profile = 1"
  fi

  query="
    ${update_query};
    INSERT INTO Profiles
    (profile_name,
     conf_file,
     default_profile,
     creation_date,
     update_date)
    VALUES (
     '$DBM_PROFILE_NAME',
     '$DBM_PROFILE_FILENAME',
     '$DBM_PROFILE_DEFAULT',
     DATETIME('now'),
     DATETIME('now')
    );
    SELECT last_insert_rowid() AS rowid
    FROM Profiles
    LIMIT 1
  "

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Error on insert profile $DBM_PROFILE_NAME."

  if [ -n "$_sqlite_ans" ] ; then
    out_handler_print "Created profile $_sqlite_ans."
  fi

  out_handler_clean

  return 0
}
# dbm_dbm_add_profile_end

# dbm_dbm_del_profile
dbm_del_profile () {

  local result=1
  local query=""
  local where_cond=""
  local profile=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_prof_args "$@" || return $result

  _dbm_save2history "dbrm dbm del_profile $args"

  if [ $DBM_PROFILE_BYID -eq 1 ] ; then
    where_cond="id_profile = $DBM_PROFILE_ID"
    profile="$DBM_PROFILE_ID"
  else
    where_cond="profile_name = '$DBM_PROFILE_NAME'"
    profile="$DBM_PROFILE_NAME"
  fi

  query="
    DELETE FROM Profiles
    WHERE ${where_cond}"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Error on delete profile."

  out_handler_print "Profile $profile is been deleted."

  out_handler_clean

  return 0
}
# dbm_dbm_del_profile_end

# dbm_dbm_set_profile
dbm_set_profile () {

  local result=1
  local query=""
  local where_cond=""
  local profile=""
  local is_present_default=0
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_prof_args "$@" || return $result

  _dbm_save2history "dbrm dbm set_profile $args"

  # Check if present a default profile
  query="
    SELECT COUNT(1)
    FROM Profiles
    WHERE default_profile = 1"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Error on check if is present a default profile"

  if [ x"$_sqlite_ans" != x"0" ] ; then
    is_present_default=1
  fi

  if [ $is_present_default -eq 1 ] ; then
    update_query="
      UPDATE Profiles
      SET default_profile = 0, update_date = DATETIME('now')
      WHERE default_profile = 1"
  fi

  if [ $DBM_PROFILE_BYID -eq 1 ] ; then

    where_cond="id_profile = $DBM_PROFILE_ID"
    profile="$DBM_PROFILE_ID"
    _dbm_check_if_exist_prof_byid "$profile" || error_handled ""

  else

    where_cond="profile_name = '$DBM_PROFILE_NAME'"
    profile="$DBM_PROFILE_NAME"
    _dbm_check_if_exist_prof_byname "$profile" || error_handled ""

  fi

  query="
    ${update_query};
    UPDATE Profiles
    SET default_profile = 1, update_date = DATETIME('now')
    WHERE ${where_cond}"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Error on set profile $profile."

  out_handler_print "Profile $profile is now set as default."

  out_handler_clean

  return 0
}
# dbm_dbm_set_profile_end

# dbm_dbm_insert_release
dbm_insert_release () {

  local result=1
  local query=""
  local id_branch=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_ins_rel_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_release $args"

  if [ -z "$DBM_REL_BRANCH" ] ; then

    id_branch="(SELECT id_branch FROM Branches WHERE name = 'master')"

  else

    _dbm_check_if_exist_id_branch "$DBM_REL_BRANCH"
    id_branch="$DBM_REL_BRANCH"

  fi

  if [ -z "$DBM_REL_ORDER" ] ; then

    query="INSERT INTO Releases
      (name,version,release_date,db_adapter,creation_date,
       update_date,id_order, id_branch,directory)
      VALUES
      ('$DBM_REL_NAME', '$DBM_REL_VERSION' ,$DBM_REL_DATE,'$DBM_REL_ADAPTER',DATETIME('now'),
       DATETIME('now'),
       (SELECT T.ID FROM (
        SELECT MAX(id_order)+1 AS ID, 1 AS T from Releases
        WHERE id_branch = $id_branch
        UNION SELECT 1 AS ID, 0 AS T
        ) T
       WHERE ID IS NOT NULL ORDER BY T.T DESC LIMIT 1),
       $id_branch, '$DBM_REL_DIR')"

  else
    query="INSERT INTO Releases
      (name,version,release_date,db_adapter,creation_date,
       update_date,id_order, id_branch,directory)
      VALUES
      ('$DBM_REL_NAME','$DBM_REL_VERSION',$DBM_REL_DATE,'$DBM_REL_ADAPTER',DATETIME('now'),
       DATETIME('now'), $DBM_REL_ORDER, $id_branch, '$DBM_REL_DIR')"
  fi

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Release $DBM_REL_NAME v. $DBM_REL_VERSION insert correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_release

# dbm_remove_release
dbm_remove_release () {

  local result=1
  local query=""
  local id_branch=""
  local cnt=""
  local cofirm=0

  # Shift first two input param
  shift 2

  _dbm_check_rem_rel_args "$@" || return $result

  # Retrive id branch of the release
  _dbm_retrieve_field_rel_byid "id_branch" "$DBM_REL_ID"
  id_branch=$_sqlite_ans

  # Check if there is some dependency with release
  query="SELECT count(1) AS CNT
    FROM ReleasesDependencies
    WHERE id_release_dep = $DBM_REL_ID"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error on check for dependencies"
  cnt=$_sqlite_ans

  if [ $cnt -ne 0 ] ; then

    error_handled "There are dependencies with release $DBM_REL_ID. You must remove these dependencies before remove release $DBM_REL_ID."

  fi

  if [ $DBM_FORCE_RM -eq 1 ] ; then
    confirm=1
  else
    confirmation_question "Are you sure to remove release with id $DBM_REL_ID? [N/y]"
    if [ $? -eq 0 ] ; then
      confirm=1
    fi
  fi

  if [ $confirm -eq 1 ] ; then

    _dbm_remove_all_scripts_rel_ded $DBM_REL_ID || error_handled "Unexpected error on remove all scripts from ScriptRelDedicated table"

    _dbm_remove_all_scripts_rel_inhib  $DBM_REL_ID || error_handled "Unexpected error on remove all scripts from ScriptRelInhibitions table"

    _dbm_remove_release $DBM_REL_ID || error_handled "Unexpected error on remove release with id $DBM_REL_ID."

    _dbm_update_idorder $id_branch || error_handled "Unexpected error on update id_order"

    out_handler_print "Release $DBM_REL_ID is been removed."

  fi

  result=0

  return $result
}
# dbm_remove_release_end

# dbm_dbm_remove_script
dbm_remove_script () {

  local result=1
  local query=""

  # Shift first two input param
  shift 2

  _dbm_check_rm_script_args "$@" || return $result

  query="DELETE FROM ScriptRelInhibitions WHERE id_script = $DBM_SCRIPT_ID; DELETE FROM Scripts WHERE id_script = $DBM_SCRIPT_ID"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Script $DBM_SCRIPT_ID removed correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_remove_script_end

# dbm_dbm_update_script
dbm_update_script () {

  local result=1
  local query=""
  local query_sub=""
  local upd_elems=0
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_upd_script_args "$@" || return $result

  _dbm_save2history "dbrm dbm update_script $args"

  if [ ! -z "$DBM_SCRIPT_FILENAME" ] ; then

    if [ $upd_elems -eq 0 ] ; then
      query_sub="SET filename = '$DBM_SCRIPT_FILENAME'"
    else
      query_sub="${query_sub}, filename = '$DBM_SCRIPT_FILENAME'"
    fi

    let upd_elems++

  fi

  if [ ! -z "$DBM_SCRIPT_TYPE" ] ; then

    if [ $upd_elems -eq 0 ] ; then
      query_sub="SET type = '$DBM_SCRIPT_TYPE'"
    else
      query_sub="${query_sub}, type = '$DBM_SCRIPT_TYPE'"
    fi

    let upd_elems++

  fi

  if [ ! -z "$DBM_SCRIPT_ACTIVE" ] ; then

    if [ $upd_elems -eq 0 ] ; then
      query_sub="SET active = '$DBM_SCRIPT_ACTIVE'"
    else
      query_sub="${query_sub}, active = '$DBM_SCRIPT_ACTIVE'"
    fi

    let upd_elems++

  fi

  if [ ! -z "$DBM_SCRIPT_DIRECTORY" ] ; then

    if [ $upd_elems -eq 0 ] ; then
      query_sub="SET directory = '$DBM_SCRIPT_DIRECTORY'"
    else
      query_sub="${query_sub}, directory = '$DBM_SCRIPT_DIRECTORY'"
    fi

    let upd_elems++

  fi

  if [ -z "$DBM_SCRIPT_ID_RELEASE" ] ; then

    if [[ ! -z "$DBM_SCRIPT_REL_VERSION" && ! -z "$DBM_SCRIPT_REL_NAME" ]] ; then

      id_rel_query="(SELECT id_release FROM Releases \
        WHERE name = '$DBM_SCRIPT_REL_NAME' AND version = '$DBM_SCRIPT_REL_VERSION')"
      if [ $upd_elems -eq 0 ] ; then
        query_sub="SET id_release = $id_rel_query"
      else
        query_sub="${query_sub}, id_release = $id_rel_query"
      fi

      let upd_elems++

    fi

  else

    if [ $upd_elems -eq 0 ] ; then
      query_sub="SET id_release = '$DBM_SCRIPT_ID_RELEASE'"
    else
      query_sub="${query_sub}, id_release = '$DBM_SCRIPT_ID_RELEASE'"
    fi

    let upd_elems++

  fi

  if [ ! -z "$DBM_SCRIPT_ID_ORDER" ] ; then

    if [ $upd_elems -eq 0 ] ; then
      query_sub="SET id_order = '$DBM_SCRIPT_ID_ORDER'"
    else
      query_sub="${query_sub}, id_order = '$DBM_SCRIPT_ID_ORDER'"
    fi

    let upd_elems++

  fi

  if [ $upd_elems -gt 0 ] ; then

    query="UPDATE Scripts ${query_sub}, update_date = DATETIME('now') WHERE id_script = $DBM_SCRIPT_ID"
    _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
    ans=$?

    if [ x"$ans" = x"0" ] ; then
      echo "Script $DBM_SCRIPT_ID updated correctly."
    fi

    result=$ans

  else

    echo -en "No elements to update for script $DBM_SCRIPT_ID.\n"

  fi

  return $result
}
# dbm_dbm_update_script_end

# dbm_dbm_insert_script
dbm_insert_script () {

  local result=1
  local query=""
  local id_rel_query=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_ins_script_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_script $args"

  if [ -z "$DBM_SCRIPT_ID_RELEASE" ] ; then
    id_rel_query="(SELECT id_release FROM Releases WHERE name = '$DBM_SCRIPT_REL_NAME' AND version = '$DBM_SCRIPT_REL_VERSION')"
  else
    id_rel_query="$DBM_SCRIPT_ID_RELEASE"
  fi

  query="INSERT INTO Scripts (filename,type,active,directory,id_release,creation_date,update_date,id_order) \
    VALUES ('$DBM_SCRIPT_FILENAME', '$DBM_SCRIPT_TYPE' ,$DBM_SCRIPT_ACTIVE,'$DBM_SCRIPT_DIRECTORY', \
    $id_rel_query, DATETIME('now'),DATETIME('now'),"

  if [ -z "$DBM_SCRIPT_ID_ORDER" ] ; then

    query="${query} (SELECT T.ID FROM \
      ( \
      SELECT MAX(ID_ORDER)+1 AS ID, 1 AS T FROM Scripts \
      WHERE ID_RELEASE = $id_rel_query \
      UNION SELECT 1 AS ID, 0 AS T \
      ) T WHERE ID IS NOT NULL ORDER BY T.T DESC LIMIT 1))"

  else

    query="${query} ${DBM_SCRIPT_ID_ORDER})"

  fi

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Script $DBM_SCRIPT_FILENAME insert correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_script_end

# dbm_dbm_insert_script_type
dbm_insert_script_type () {

  local result=1
  local query=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_ins_script_type_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_script_type $args"

  query="INSERT INTO ScriptTypes (code,descr) VALUES ('$DBM_SCRIPT_TYPE_CODE', '$DBM_SCRIPT_TYPE_DESCR')";

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Script Type $DBM_SCRIPT_TYPE_CODE insert correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_script_type_end

# dbm_dbm_insert_rel_dep
dbm_insert_rel_dep () {

  local result=1
  local query=""
  local id_rel_query_to=""
  local id_rel_query_from=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_rel_dep_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_rel_dep $args"

  id_rel_query_to="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_TO')"
  id_rel_query_from="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_FROM')"

  query="INSERT INTO ReleasesDependencies (id_release,id_release_dep,creation_date) \
    VALUES (${id_rel_query_to}, ${id_rel_query_from}, DATETIME('now'))"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Insert release dependency to $DBM_REL_NAME v.$DBM_REL_VERSION_TO correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_rel_dep

# dbm_dbm_remove_rel_dep
dbm_remove_rel_dep () {

  local result=1
  local query=""
  local id_rel_query_to=""
  local id_rel_query_from=""

  # Shift first two input param
  shift 2

  _dbm_check_rel_dep_args "$@" || return $result

  id_rel_query_to="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_TO')"
  id_rel_query_from="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_FROM')"

  query="DELETE FROM ReleasesDependencies \
    WHERE id_release = ${id_rel_query_to} AND id_release_dep = ${id_rel_query_from}"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Remove release dependencty to $DBM_REL_NAME v.$DBM_REL_VERSION_TO with $DBM_REL_VERSION_FROM correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_remove_rel_dep_end

# dbm_dbm_insert_inhibit_script
dbm_insert_inhibit_script () {

  local result=1
  local query=""
  local id_rel_query_to=""
  local id_rel_query_from=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_inhibit_script_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_inhibit_script $args"

  id_rel_query_to="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_TO')"
  id_rel_query_from="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_FROM')"

  query="INSERT INTO ScriptRelInhibitions (id_script,id_release_from,id_release_to,creation_date) \
    VALUES ($DBM_SCRIPT_ID, ${id_rel_query_from}, ${id_rel_query_to}, DATETIME('now'))"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Record insert correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_inhibit_script_end

# dbm_dbm_insert_ded_script
dbm_insert_ded_script () {

  local result=1
  local query=""
  local id_rel_query_to=""
  local id_rel_query_from=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_inhibit_script_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_ded_script $args"

  id_rel_query_to="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_TO')"
  id_rel_query_from="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_FROM')"

  query="INSERT INTO ScriptRelDedicated (id_script,id_release_from,id_release_to,creation_date) \
    VALUES ($DBM_SCRIPT_ID, ${id_rel_query_from}, ${id_rel_query_to}, DATETIME('now'))"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Record insert correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_ded_script_end

# dbm_dbm_remove_inhibit_script
dbm_remove_inhibit_script () {

  local result=1
  local query=1
  local id_rel_query_to=""
  local id_rel_query_from=""

  # Shift first two input param
  shift 2

  _dbm_check_inhibit_script_args "$@" || return $result

  id_rel_query_to="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_TO')"
  id_rel_query_from="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_FROM')"

  query="DELETE FROM ScriptRelInhibitions \
    WHERE id_script = $DBM_SCRIPT_ID \
    AND id_release_from = ${id_rel_query_from} \
    AND id_release_to = ${id_rel_query_to}"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Record removed correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_remove_inhibit_script_end

# dbm_dbm_remove_ded_script
dbm_remove_ded_script () {

  local result=1
  local query=1
  local id_rel_query_to=""
  local id_rel_query_from=""

  # Shift first two input param
  shift 2

  _dbm_check_inhibit_script_args "$@" || return $result

  id_rel_query_to="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_TO')"
  id_rel_query_from="(SELECT id_release FROM Releases WHERE name = '$DBM_REL_NAME' AND version = '$DBM_REL_VERSION_FROM')"

  query="DELETE FROM ScriptRelDedicated \
    WHERE id_script = $DBM_SCRIPT_ID \
    AND id_release_from = ${id_rel_query_from} \
    AND id_release_to = ${id_rel_query_to}"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Record removed correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_remove_ded_script_end

# dbm_dbm_show_branches
dbm_show_branches () {

  _sqlite_query -c "$DRM_DB" -q "SELECT COUNT(1) AS R FROM Branches" || error_handled "Unexpected error!"

  local n_rec=$_sqlite_ans
  local creation_date=""
  local update_date=""
  local counter=0

  [[ $DEBUG ]] && echo -en "N. Branches: $n_rec\n"

  if [ x$n_rec != x0 ] ; then

    _sqlite_query -c "$DRM_DB" -q "SELECT id_branch,name,creation_date,update_date FROM Branches ORDER BY id_branch ASC" || error_handled "Unexpected error!"

    out_hsep=1
    out_prepost_mode="any"
    out_htabs_mode="tabs"

    out_headers[0]="ID"
    out_headers[1]="CREATION_DATE"
    out_headers[2]="UPDATE_DATE"
    out_headers[3]="NAME"

    out_el_pre[0]="\e[1;33m"
    out_el_pre[1]="\e[1;32m"
    out_el_pre[2]="\e[1;31m"
    out_el_pre[3]="\e[1;34m"

    out_el_post[0]="\e[m"

    out_tabs[0]="10"
    out_tabs[1]="24"
    out_tabs[2]="24"
    out_tabs[3]="10"

    IFS=$'\n'
    for row in $_sqlite_ans ; do

      #[[ $DEBUG ]] && echo "ROW = ${row}"

      id_branch=`echo $row | awk '{split($0,a,"|"); print a[1]}'`
      name=`echo $row | awk '{split($0,a,"|"); print a[2]}'`
      creation_date=`echo $row | awk '{split($0,a,"|"); print a[3]}'`
      update_date=`echo $row | awk '{split($0,a,"|"); print a[4]}'`

      out_rows[$counter]="row"${counter}

      eval "row${counter}[0]=\"${id_branch}\""
      eval "row${counter}[1]=\"${creation_date}\""
      eval "row${counter}[2]=\"${update_date}\""
      eval "row${counter}[3]=\"${name}\""

      let counter++

    done
    unset IFS

    out_handler_print_arr

  else
    out_handler_print "No branches available."
  fi

  out_handler_clean

  return 0
}
# dbm_dbm_show_branches

# dbm_dbm_insert_branch
dbm_insert_branch () {

  local result=1
  local query=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_ins_bra_args "$@" || return $result

  _dbm_save2history "dbrm dbm insert_branch $args"

  query="INSERT INTO Branches (name,creation_date,update_date) \
         VALUES ('$DBM_BRA_NAME', DATETIME('now'),DATETIME('now'))"

  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error!"
  ans=$?

  if [ x"$ans" = x"0" ] ; then
    echo "Branches $DBM_BRA_NAME insert correctly."
  fi

  result=$ans

  return $result
}
# dbm_dbm_insert_branch_end

# dbm_move_script
dbm_move_script () {

  local result=1
  local id_order_from=""
  local id_order_to=""
  local create_tmp_table=""
  local move_others=""
  local args=""

  # Shift first two input param
  shift 2

  args="$@"

  _dbm_check_move_script_args "$@" || return $result

  _dbm_check_if_exist_id_rel "$DBM_REL_ID" || return $result

  _dbm_check_if_exist_id_script "$DBM_SCRIPT_ID_FROM" "$DBM_REL_ID" || return $result

  _dbm_check_if_exist_id_script "$DBM_SCRIPT_ID_TO" "$DBM_REL_ID" || return $result

  _dbm_save2history "dbrm dbm move_script $args"

  _dbm_retrieve_field_script "id_order" "$DBM_SCRIPT_ID_FROM"
  id_order_from=$_sqlite_ans

  _dbm_retrieve_field_script "id_order" "$DBM_SCRIPT_ID_TO"
  id_order_to=$_sqlite_ans

  if [ $DBM_AFTER -eq 1 ] ; then

    if  [ $id_order_to -lt $id_order_from ] ; then

      where_moved_record="( id_order > $id_order_to AND id_order < $id_order_from )"

      insert2tmp="INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, $id_order_to+1 as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE id_script = $DBM_SCRIPT_ID_FROM ;
        INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release,id_order+1 as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE $where_moved_record "

    else

      where_moved_record="id_order > $id_order_from "

      insert2tmp="INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, id_order-1 as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE id_order > $id_order_from AND id_order <= $id_order_to ;
        INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, id_order,
               creation_date, update_date
        FROM Scripts
        WHERE id_order > $id_order_to ;
        INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, $id_order_to as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE id_script = $DBM_SCRIPT_ID_FROM "

    fi

    t="after"

    result=0

  else

    if [ $id_order_to -lt $id_order_from ] ; then

      where_moved_record=" id_order < $id_order_from
        AND id_order >= $id_order_to AND id_release = $DBM_REL_ID "

      insert2tmp="INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, id_order+1 as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE $where_moved_record ;
        INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, $id_order_to as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE id_script = $DBM_SCRIPT_ID_FROM "

    else

      where_moved_record="id_order < $id_order_to
        AND id_order > $id_order_from AND id_release = $DBM_REL_ID "

      insert2tmp="INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, id_order-1 as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE $where_moved_record ;
        INSERT INTO ScriptsTemp
        SELECT id_script, filename, type, active,
               directory, id_release, $id_order_to-1 as id_order,
               creation_date, update_date
        FROM Scripts
        WHERE id_script = $DBM_SCRIPT_ID_FROM "


    fi

    t="before"
    result=0

  fi

  # Create temporary table ddl for script move
  _dbm_get_table_schema "Scripts"
  create_tmp_table="$(echo "$_sqlite_ans" | sed 's/TABLE Scripts/TABLE ScriptsTemp/')"

  delete_scripts="DELETE FROM Scripts
    WHERE ($where_moved_record) OR
    (id_release = $DBM_REL_ID AND id_order = $id_order_from ) "

  # Disable PRAGMA options
  SQLITEDB_INIT_SESSION=" "

  query="DROP TABLE IF EXISTS ScriptsTemp ;
    $create_tmp_table
    ${insert2tmp} ;
    ${delete_scripts} ;
    INSERT INTO Scripts
    SELECT id_script, filename, type, active,
           directory, id_release, id_order,
           creation_date, DATETIME('now')
    FROM ScriptsTemp
    WHERE id_release = $DBM_REL_ID ;
    DROP TABLE ScriptsTemp "

  #  SELECT * FROM ScriptsTemp ;
  #  SELECT '-'  ;
  #  SELECT * FROM Scripts ;
  _sqlite_query -c "$DRM_DB" -q "$query" || error_handled "Unexpected error on update id_order fields."

  # Re-enable PRAGMA options
  unset SQLITEDB_INIT_SESSION

  echo -en "Moved correctly script $DBM_SCRIPT_ID_FROM of the release $DBM_REL_ID ${t} script $DBM_SCRIPT_ID_TO.\n"

  return $result
}
# dbm_move_script_end

# dbm_dbm_upgrade
dbm_upgrade () {

  # Shift first two input param
  shift 2

  _dbm_upgrade "$@" || return 1

  return 0

}
# dbm_dbm_upgrade_end


##################################################################
# Internal functions
##################################################################

# dbm__dbm_init
_dbm_init() {

  # Load dbm module files
  for i in $DBRM_CORE_FILES_DIR/dbm/*.inc ; do
    . $i
  done

  return 0
}
# dbm__dbm_init_end

# dbm__dbm_post_init
_dbm_post_init () {

  # Check if exists DRM_DB
  [[ $DEBUG ]] && echo "(dbm_post_init: Check if is present sqlite internal db file: $DRM_DB)"
  if [[ ! -e $DRM_DB ]] ; then

    if [[ -z "$DRM_PROFILE" || $DRM_PROFILE -eq 0 ]] ; then
      [[ $DEBUG ]] && echo "(dbm_post_init: Create sqlite internal db file: $DRM_DB)"
      _sqlite_create -c "$DRM_DB" -s "$dbm_schema" || error_handled "Error on create $DRM_DB file."

      _dbm_exts_check_extensions "0" || error_handled "Error on initialize extensions."

    fi

  else

    if [[ x"$2" != x"upgrade" && x"$2" != x"shell" && x"$2" != x"info" ]] ; then
      # Check if it is needed an upgrade
      _dbm_exts_check_dbm || error_handled \
        "Execute 'dbrm dbm upgrade' to upgrade internal database."
    fi

  fi

  # Check if is defined undo script path
  if [[ -z "$DBM_UNDO_SCRIPT" ]] ; then
      # Use default path
      DBM_UNDO_SCRIPT=$LOCAL_DIR/dbm_undo.sh
  else
    if [[ ! -e $DBM_UNDO_SCRIPT ]] ; then
      error_generate "Invalid DBM Undo script path defined."
    fi
  fi

  # Check if is defined history script path
  if [[ -z "$DBM_HISTORY" ]] ; then
      # Use default path
      DBM_HISTORY=$LOCAL_DIR/.dbm_history
  else
    if [[ ! -e $DBM_HISTORY ]] ; then
      error_generate "Invalid DBM history file path defined."
    fi
  fi

  [[ $DEBUG ]] && echo "(dbm_post_init: Use undo script: $DBM_UNDO_SCRIPT.)"

  export DBM_UNDO_SCRIPT DBM_HISTORY
}
# dbm__dbm_post_init_end


# dbm__dbm_upgrade
_dbm_upgrade () {

  local i=0
  local tschema=""

  # Check if all tables are present
  for i in $dbm_tables ; do

    if _sqlite_exists_table -c "$DRM_DB" -t "$i" ; then

      _sqlite_get_tschema_from_file "$dbm_schema" "$i" || \
        error_generate "Error on retrieve schema of the table $i."

      query="$_sqlite_ans"

      _sqlite_query -c "$DRM_DB" -q "$query" || \
        error_handled "Error on create table $i."

      out_handler_print "Created table $i correctly."

    fi

  done

  # Check if all modules are present on Extensions table.
  _dbm_exts_check_extensions || error_generate "Error on verify extentensions."

  # Check if it is needed execute upgrade scripts for dbm module.

  return 0

}
# dbm__dbm_upgrade_end

# vim: syn=sh filetype=sh ts=2 sw=2
